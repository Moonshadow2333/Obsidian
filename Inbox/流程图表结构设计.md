
[关于OA流程相关数据表的设计 - kingeric - 博客园 (cnblogs.com)](https://www.cnblogs.com/kingeric/p/11638940.html)
[流程图存储的方案设计及数据结构设计_流程图 数据结构-CSDN博客](https://blog.csdn.net/qq_36657997/article/details/129425170)
[设计思想 - 工作流表结构的设计 - 个人文章 - SegmentFault 思否](https://segmentfault.com/a/1190000019161083)
[流程图的导出与导入：实现流程图的持久化存储-CSDN博客](https://blog.csdn.net/universsky2015/article/details/136010710)
[可拖拽流程图的实现+代码按流程图执行-腾讯云开发者社区-腾讯云 (tencent.com)](https://cloud.tencent.com/developer/article/1410551)
[前端流程图插件对比选型 - 掘金 (juejin.cn)](https://juejin.cn/post/7251835247595110457)
[介绍 (logic-flow.cn)](https://docs.logic-flow.cn/docs/#/zh/guide/start)
[边上插入节点 InsertNodeInPolyline (logic-flow.cn)](https://docs.logic-flow.cn/docs/#/zh/guide/extension/extension-insert-node-in-polyline)
[拖拽创建节点 Dnd (logic-flow.cn)](https://docs.logic-flow.cn/docs/#/zh/guide/basic/dnd)


## 原生js用npm引入其他包

[HTML 如何在HTML中以普通的JavaScript使用NPM包|极客笔记 (deepinout.com)](https://deepinout.com/html/html-questions/97_html_how_to_use_npm_package_as_normal_javascript_in_html.html)


## 引用问题

Failed to resolve module specifier "@logicflow/core". Relative references must start with either "/", "./", or "../"、

[Failed to resolve module specifier. Relative references must start with either | bobbyhadz](https://bobbyhadz.com/blog/failed-to-resolve-module-specifier-javascript)


[LogicFlow 在HTML中的引入与使用 - 简书 (jianshu.com)](https://www.jianshu.com/p/98cd767b985b)


## 引入NPM包

[HTML 如何在HTML中以普通的JavaScript使用NPM包|极客笔记 (deepinout.com)](https://deepinout.com/html/html-questions/97_html_how_to_use_npm_package_as_normal_javascript_in_html.html)


## “Error: 请检查 container 参数是否有效”

[按照官方快速上手教程使用失败，提示“Error: 请检查 container 参数是否有效” · Issue #197 · didi/LogicFlow (github.com)](https://github.com/didi/LogicFlow/issues/197)

因为渲染LogicFlow的时候，container传入的节点还没有被渲染到dom上吧，你setTimeout延迟1秒渲染LogicFlow试试。

其实不是上面的问题，而是自己没有写 id 为 container 的div盒子，继续看[LogicFlow实例 (logic-flow.cn)](https://docs.logic-flow.cn/docs/#/zh/guide/basic/logic-flow)就知道了。


```HTML
<!DOCTYPE html>

<html lang="en">

<head>

    <meta charset="UTF-8">

    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <title>Document</title>

    <link href="node_modules/@logicflow/core/dist/style/index.css" rel="stylesheet">

    <link rel="stylesheet" href="node_modules/@logicflow/extension/lib/style/index.css"/>

    <style>

        #container {

          width: 1000px;

          height: 500px;

        }

      </style>

</head>

<body>

  

    <div id="container"></div>

  

    <script src="node_modules/@logicflow/core/dist/logic-flow.js"></script>

    <script src="node_modules/@logicflow/core/dist/logic-flow.min.js"></script>

    <!--LogicFlow的插件支持单个引入，这里以菜单插件为例-->

    <script src="node_modules/@logicflow/extension/lib/Menu.js"></script>

  

    <script>

  

        let delay = 1000;

        function test () {

            LogicFlow.use(Menu);

            const lf = new LogicFlow({

                container: document.querySelector("#container"),

            });

  

            lf.render({

                nodes: [

                    {

                    id: "1",

                    type: "rect",

                    x: 100,

                    y: 100,

                    text: "节点1",

                    },

                    {

                    id: "2",

                    type: "circle",

                    x: 300,

                    y: 200,

                    text: "节点2",

                    },

                ],

                edges: [

                    {

                    sourceNodeId: "1",

                    targetNodeId: "2",

                    type: "polyline",

                    text: "连线",

                    },

                ],

            });

        }

        setTimeout(test, delay);

    </script>

</body>

</html>
```

## 拖拽

[LogicFlow 自定义可分组拖拽面板 - 前端小鑫同学 - 博客园 (cnblogs.com)](https://www.cnblogs.com/ospoon/p/18152810)

## 获取所有下一节点

```JS
let graphModel = lf.graphModel;

        // console.log(graphModel.nodesMap);

        let nodesMap = graphModel.nodesMap;

        // console.log(typeof nodesMap); // object

        for (nodeId in nodesMap) {

            var firstNodeId = nodeId;

            break;

        }

        console.log(firstNodeId);

        // 获取所有下一节点

        var outcomingNodes = graphModel.getNodeOutgoingNode(firstNodeId);

        console.log(typeof outcomingNodes); // object

        for (key in outcomingNodes) {

            console.log(outcomingNodes[key].id);

            console.log(outcomingNodes[key].text.value);

        }
```

如果当前节点没有下一节点，返回的是一个对象，但不是空的。不能用下面的方式判断：

```JS
    let data = {};
    let data1 = {
        name: "大帅哥",
        age: "18"
    }
   console.log(JSON.stringify(data) === '{}') // true
   console.log(JSON.stringify(data1) === '{}') // false
```

可以根据返回的对象中的 length 属性来判断：

```JS
function isNoOutgoingNodes(data) {
        return data.length === 0;
    }
```

```JS
    function traverse (graphModel, nodeId) {

        var outgoingNodes = graphModel.getNodeOutgoingNode(nodeId);

        if (isNoOutgoingNodes(outgoingNodes)) {

            return;

        }

        for (key in outgoingNodes) {

            console.log(outgoingNodes[key].text.value);

            traverse(graphModel, outgoingNodes[key].id);

        }

    }
```

## 变量作用域问题

递归完后都会多一个根节点，经过一步步排查后才发现是是变量域的问题，即 for in 循环里面，key 前面要加一个 let

### 有 bug 的代码

```JS
function traverse (graphModel, nodeId, depth) {

        var outgoingNodes = graphModel.getNodeOutgoingNode(nodeId);

        if (isNoOutgoingNodes(outgoingNodes)) {

            return;

        }

        for (key in outgoingNodes) {

            var depthStr = generateDepthString(depth);

            console.log('前序输入：' + graphModel.getNodeModelById(nodeId).text.value + 'ID，' +  depthStr + outgoingNodes[key].text.value + ', ' + 'currentKey: ' + key + ', lastKey: '+getLastKey(outgoingNodes));

  

            traverse(graphModel, outgoingNodes[key].id, depth + 1);

            // console.log(key);

            // console.log(getLastKey(outgoingNodes));

            // console.log(key !== getLastKey(outgoingNodes));

            // if (outgoingNodes.length > 1 && key !== getLastKey(outgoingNodes)) {

                // console.log(key);

                // console.log(getLastKey(outgoingNodes));

                // console.log('--+++ outgoingNodes[key].text.value');

                var parentNode = graphModel.getNodeModelById(nodeId);

                console.log('后序输入：' + graphModel.getNodeModelById(nodeId).text.value + 'ID，' + depthStr + parentNode.text.value + ', ' + outgoingNodes[key].text.value + ', ' + 'currentKey: ' + key + ', lastKey: '+getLastKey(outgoingNodes));

            // }

        }

    }
```

![](./images/Snipaste_2024-05-19_10-57-34.png)

### 排除 bug 后的代码

```JS
function traverse (graphModel, nodeId, depth) {

        var outgoingNodes = graphModel.getNodeOutgoingNode(nodeId);

        if (isNoOutgoingNodes(outgoingNodes)) {

            return;

        }

        for (let key in outgoingNodes) {

            var depthStr = generateDepthString(depth);

            console.log('前序输入：' + graphModel.getNodeModelById(nodeId).text.value + 'ID，' +  depthStr + outgoingNodes[key].text.value + ', ' + 'currentKey: ' + key + ', lastKey: '+getLastKey(outgoingNodes));

  

            traverse(graphModel, outgoingNodes[key].id, depth + 1);

            // console.log(key);

            // console.log(getLastKey(outgoingNodes));

            // console.log(key !== getLastKey(outgoingNodes));

            // if (outgoingNodes.length > 1 && key !== getLastKey(outgoingNodes)) {

                // console.log(key);

                // console.log(getLastKey(outgoingNodes));

                // console.log('--+++ outgoingNodes[key].text.value');

                var parentNode = graphModel.getNodeModelById(nodeId);

                console.log('后序输入：' + graphModel.getNodeModelById(nodeId).text.value + 'ID，' + depthStr + parentNode.text.value + ', ' + outgoingNodes[key].text.value + ', ' + 'currentKey: ' + key + ', lastKey: '+getLastKey(outgoingNodes));

            // }

        }

    }
```

![](./images/Snipaste_2024-05-19_10-50-48.png)

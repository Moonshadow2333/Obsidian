---
aliases:
  - 数据库
date: 2025-06-25
---

# 目录

```dataviewjs
const startHeadinglevel = 2;
const file = app.workspace.getActiveFile();
const { headings } = app.metadataCache.getFileCache(file);
 
// 全列表的形式
const raws = headings.filter(row => row.heading != "目录").map( p => {
    let repeatCount = Math.max((p.level - startHeadinglevel) * 4, 0);
    let spacesPrefix = ' '.repeat( repeatCount + 4 );
    let listSign = repeatCount > 0 ? '- ' : '';
    let linkText = `[[#${p.heading}]]`;
    let headingList = (p.level < startHeadinglevel) ? `- ${linkText}` : `${spacesPrefix}- ${linkText}`;
    return headingList;
  }
)
 
let result = raws.join('\n');
// 添加行距
dv.container.style.lineHeight = "1.5em";
dv.paragraph(result)
```

# 删除异常

## 定义

删除异常指在删除某些数据时，意外地丢失了其他有价值的数据，破坏了数据的完整性。

## 产生原因

主要源于数据库设计未达到合适的范式，存在数据冗余和传递依赖、部分依赖等不合理的函数依赖关系。

## 示例

假设一个学生选课关系模式R(学号, 姓名, 课程号, 课程名, 成绩)，这里候选码是(学号, 课程号)。

若要删除某个学生的所有选课记录，比如删除学号为001学生的所有选课信息，由于课程名和课程号是冗余存储在每条选课记录中的，删除该学生所有记录后，可能导致该课程的课程名信息也丢失了，如果后续其他学生要选这门课，就无法获取课程名。
原因在于课程名和课程号之间的函数依赖与学生选课的依赖没有合理分离，使得删除学生选课记录时，附带删除了课程相关的重要信息。

## 解决办法

对数据库进行规范化设计，将关系模式分解到合适的范式，比如将上述关系模式分解为学生表(学号, 姓名)、课程表(课程号, 课程名)和选课表(学号, 课程号, 成绩)，这样删除学生选课记录就不会影响课程信息。

# 更新异常

## 定义

当修改某条数据的某个属性时，需强制更新多条冗余记录，否则会导致数据不一致性。

## 典型示例

场景：学生选课表 SC(Sno, Dname, Cno)

Dname 是学生院系
假设存在依赖 Sno→Dname（院系由学号决定，候选键为 (Sno,Cno)）
问题操作：
修改某学生的院系时，需更新该学生所有选课记录中的 Dname。一旦遗漏部分记录，同一学生在不同课程记录中院系信息将矛盾。

## 产生原因

冗余存储：院系信息（Dname）重复存储在每一条选课记录中
部分依赖：Dname仅依赖候选键的一部分（Sno而非完整键(Sno,Cno)） → 违反2NF

# 插入异常

## 定义

- 插入异常指在向数据库表中插入数据时，由于表结构和数据依赖关系的限制，无法正常插入某些数据，或者插入数据会导致数据的不一致性。
- 当需要插入必要数据时，==因缺少主键部分属性导致无法独立插入，造成关键信息被迫缺失==。

## 产生原因

主要是数据库表的设计没有遵循合适的范式，存在部分依赖、传递依赖等问题，使得一些数据的插入必须依赖其他数据的存在。

## 示例

假设有一个关系模式R(学号, 课程号, 系名, 系主任)，函数依赖关系为：学号 -> 系名，系名 -> 系主任，候选码是(学号, 课程号)。

情况一：插入新学生信息：当一个学生刚入学，还未选课，由于候选码是(学号, 课程号)，没有课程号就无法插入该学生的学号、系名和系主任等信息。
情况二：插入新系信息：如果要新增一个系，但该系还没有学生选课，同样因为缺少学号和课程号组合的候选码，无法插入系名和系主任信息。

## 解决办法

对表进行规范化设计，将表分解成符合更高范式的多个表。针对上述示例，可以将其分解为：

学生选课表：SC(学号, 课程号)，候选码是(学号, 课程号)。
学生系信息表：S(学号, 系名)，候选码是学号。
系信息表：D(系名, 系主任)，候选码是系名。
这样，插入新学生时，即使未选课也能在S表插入学生系信息；插入新系时，能在D表直接插入系信息。


# 数据冗余

## 定义

数据冗余是指在数据库中同一信息被多次存储，导致不必要的重复和潜在的不一致性。

## 典型示例

场景：学生选课表 SC(Sno, Sname, Cno, Cname)

Sno 是学号
Sname 是学生姓名
Cno 是课程号
Cname 是课程名称
假设依赖关系：Sno → Sname 和 Cno → Cname

问题：

每个学生的姓名 Sname 在每条选课记录中重复存储。
每门课程的名称 Cname 在每条选课记录中重复存储。

## 根本原因

重复存储：同一信息（如学生姓名、课程名称）在多条记录中重复出现。
缺乏规范化：表结构设计不合理，导致信息冗余。

## 解决方法

规范化设计：


拆分表结构：

学生表：Students(Sno, Sname)（候选键 Sno）
课程表：Courses(Cno, Cname)（候选键 Cno）
选课表：SC(Sno, Cno)（外键引用 Sno 和 Cno）

使用外键关联：

通过外键将 SC 表中的 Sno 和 Cno 分别与 Students 和 Courses 表关联，避免重复存储。

总结：数据冗余会导致存储浪费和潜在的数据不一致性。通过规范化设计（如3NF），拆分表并使用外键关联，可以有效消除冗余，提高数据一致性和存储效率。
---
aliases:
  - 无损分解
date: 2025-06-15
---

# 目录

```dataviewjs
const startHeadinglevel = 2;
const file = app.workspace.getActiveFile();
const { headings } = app.metadataCache.getFileCache(file);
 
// 全列表的形式
const raws = headings.filter(row => row.heading != "目录").map( p => {
    let repeatCount = Math.max((p.level - startHeadinglevel) * 4, 0);
    let spacesPrefix = ' '.repeat( repeatCount + 4 );
    let listSign = repeatCount > 0 ? '- ' : '';
    let linkText = `[[#${p.heading}]]`;
    let headingList = (p.level < startHeadinglevel) ? `- ${linkText}` : `${spacesPrefix}- ${linkText}`;
    return headingList;
  }
)
 
let result = raws.join('\n');
// 添加行距
dv.container.style.lineHeight = "1.5em";
dv.paragraph(result)
```

# 算法

    对于关系模式R(U,F), 设P = {R1(U1,F1) , R2(U2,F2) , ... , Rn(Un,Fn)}是R的一个分解，若F+ = （UFi)+ ，则称分解P是保持函数依赖。  

    注：U：并集  

# 例子  

例：R  ={A，B，C，D，E}，F = {B → A ， D → A ， A → E , AC → B}，判断分解P ={R1（ABCE） ， R2（CD）}是否保持函数依赖

  

解：

         首先，我们需要将R1和R2的函数依赖F1，F2找到。显然有  

      

        F1 = {B → A ，A → E ， AC  → B} ，F2 = { }  


> [!note]
> 没有那么多显然 2333
> 循环遍历 F (函数依赖集)，第 i 个 函数依赖 X<sub>i</sub> -> A<sub>i</sub>，如果 X<sub>i</sub> 属于 R1，且 A<sub>i</sub> 属于 R1，那么X<sub>i</sub> -> A<sub>i</sub> 属于 F1；如果 X<sub>i</sub> 属于 R2，且 A<sub>i</sub> 属于 R2，那么 X<sub>i</sub> -> A<sub>i</sub> 属于 F2；否则既不属于 F1 也不属于 F2
> 参考：[数据库系统概论——判断分解是否保持函数依赖_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1nV411o7EU?spm_id_from=333.788.recommend_more_video.2&vd_source=081641abeed94aff322f0473e2c1773d)


        注：这样就找全了吗？其实不然，在这一步中最容易漏掉部分函数依赖，比如传递依赖等关系会因为F的分组而丢失。因此，在这一步，我的习惯是计算一下左边属性的闭包  

     

    B+ ={B,A,E} 显然 B 和 E存在传递依赖 即 B → E，同理

    D+={D，A，E} ，发现D+没有C，即D推不出C

  

   A+={A，E}

  

    (AC)+ = {A ,C , B, E}，显然 AC → A ， AC→ E

  

    综上，F1 更新为 F1 = {B → A ，A → E ， AC  → B， B → E，AC → A ， AC→ E} 

      

    F2依旧是空集  

  

    令 G = F1 ∪ F2 =  {B → A ，A → E ， AC  → B， B → E，AC → A ， AC→ E} 

  

    我们检查一下F中的函数依赖，是否在G中全部都出现，如果出现，则算法结束，保持函数依赖  

  

    发现，D → A 不在G中，此时，我们需要计算元素D在G下的闭包

  

    显然，D+ ={D} 不包含A，因此该分解不保持函数依赖。  

  

     注：如果D+ ={D ,A }，包含了A，则该分解保持函数依赖。

  
------------------------------------  
作者：程俊伟  
来源：学者网  
原文：https://www.scholat.com/vpost.html?pid=143851  
本文为该学者原创文章，转载请附上文章链接！
---
alias: 
date:
---

# 目录

```dataviewjs
const startHeadinglevel = 2;
const file = app.workspace.getActiveFile();
const { headings } = app.metadataCache.getFileCache(file);
 
// 全列表的形式
const raws = headings.filter(row => row.heading != "目录").map( p => {
    let repeatCount = Math.max((p.level - startHeadinglevel) * 4, 0);
    let spacesPrefix = ' '.repeat( repeatCount + 4 );
    let listSign = repeatCount > 0 ? '- ' : '';
    let linkText = `[[#${p.heading}]]`;
    let headingList = (p.level < startHeadinglevel) ? `- ${linkText}` : `${spacesPrefix}- ${linkText}`;
    return headingList;
  }
)
 
let result = raws.join('\n');
// 添加行距
dv.container.style.lineHeight = "1.5em";
dv.paragraph(result)
```

```python
U = ['A', 'B', 'C', 'D', 'E', 'G']

# 初始化闭包
# 更新闭包的条件
# 闭包计算结束的条件

F = [
    ['A,B', 'C'],
    ['D', 'E,G'],
    ['C', 'A'],
    ['B,E', 'C'],
    ['B,C', 'D'],
    ['C,G', 'B,D'],
    ['A,C,D', 'B'],
    ['C,E', 'A,G']
]
initAttrClosure = ['B,D']

U = ['A', 'B', 'C', 'D', 'E', 'I']
F = [
    ['A', 'D'],
    ['A,B', 'E'],
    ['B,I', 'E'],
    ['C,D', 'I'],
    ['E', 'C']
]
initAttrClosure = ['A,E']

U = ['A', 'B', 'C', 'E', 'P', 'G']
F = [
    ['A,C', 'P,E'],
    ['P,G', 'A'],
    ['B', 'C,E'],
    ['A', 'P'],
    ['G,A', 'B'],
    ['C,C', 'A'],
    ['P,A,B', 'G'],
    ['A,E', 'G,B'],
    ['A,B,C,P', 'H']
]
initAttrClosure = ['B,G']


def calculateU(F):
    U = set({})
    for FD in F:
        leftPart = set(FD[0].split(','))
        rightPart = set(FD[1].split(','))
        U = U.union(leftPart.union(rightPart))
    return U

def updateClosure(FD, closure):
    leftPart = set(FD[0].split(','))
    rightPart = set(FD[1].split(','))
    if leftPart.issubset(closure):
        if not rightPart.issubset(closure):
            return closure.union(rightPart)
    return closure 
 
def calculateAttrClosure(F, initAttrClosure):
    U = calculateU(F)
    closure = set(initAttrClosure[0].split(','))
    i = 0
    while True:
        beforeLoopClosure = closure
        for FD in F:
            updatedClosure = updateClosure(FD, closure)
            closure = updatedClosure

        afterLoopClosure = closure

        if U == closure or beforeLoopClosure == afterLoopClosure:
            break    
        beforeLoopClosure = afterLoopClosure

    return closure


def decompositionRule(FD):
    # 分解规则
    newFDs = []
    rightPartAttrs = FD[1].split(',')
    for attr in rightPartAttrs:
        newFDs.append([FD[0], attr])
    return newFDs

def calculateMinF(F):
    newF = []
    for FD in F:
        if len(FD[1].split(',')) > 1:
            newFDs = decompositionRule(FD)
            newF.extend(newFDs) 
        else:
            newF.append(FD)
    
    while True:
        nF = []
        for FD in newF:
            if not isDelFD(FD, newF):
                nF.append(FD)

        beforeF = nF
        for FD in nF:
            anF = updateF(FD, nF)
            nF = anF
        
        afterF = nF
        
        if beforeF == afterF:
            break

        newF = afterF
    print(afterF)
    # return newF

def isDelFD(FD, F):
    tryF = []
    for x in F:
        if x != FD:
            tryF.append(x)
    rightPart = set(FD[1])
    return rightPart.issubset(calculateAttrClosure(tryF, FD))

def updateF(FD, F):
    leftPartAttrs = FD[0].split(',')
    rightPart = set(FD[1])
    if len(leftPartAttrs) <= 1:
        return F
    for attr in leftPartAttrs:
        i = 0
        newInitClosure = '' 
        while i < len(leftPartAttrs):
            if leftPartAttrs[i] == attr:
                i = i + 1
                continue
            else:
                newInitClosure = newInitClosure + ',' + attr
                i = i + 1

        closure = calculateAttrClosure(F, [newInitClosure.strip(',')])
        if rightPart.issubset(closure):
            newFD = [newInitClosure.strip(','), FD[1]]
            newF = []
            for x in F:
                if x == FD:
                    newF.append(newFD)
                else:
                    if not x in newF:
                        newF.append(x)
            F = newF
    return F    

F = [
    ['B', 'D'],
    ['D,G', 'C'],
    ['B,D', 'E'],
    ['A,G', 'B'], 
    ['A,D,G', 'B'],
    ['A,D,G', 'C']
]
# newF = calculateMinF(F)


# FD = ['A,B,G', 'C,D']
# print(decompositionRule(FD))

# re = calculateAttrClosure(F, initAttrClosure)
# print(re)

# 删除 FD 的冗余属性 返回 FD
def delRedundantAttr(F, FD):
    leftPartAttrs = FD[0].split(',')
    # 经过第一步，右部单一化，FD[1] 只有一个属性
    rightPart = set(FD[1])
    if len(leftPartAttrs) <= 1:
        return FD
    
    delAttrs = []
    for attr in leftPartAttrs:
        i = 0
        newClosureStr = '' 
        while i < len(leftPartAttrs):
            if leftPartAttrs[i] != attr:
                newClosureStr = newClosureStr + ',' + leftPartAttrs[i]
            i = i + 1
        newClosure = [newClosureStr.strip(',')]
        if rightPart.issubset(calculateAttrClosure(F, newClosure)):
            delAttrs.append(attr)
    
    newDeterminant = ''
    for attr in leftPartAttrs:
       if not attr in delAttrs:
            newDeterminant = newDeterminant + ',' + attr
    return [newDeterminant.strip(','), FD[1]]


def substituteEle(F, oldFD, newFD):
    if len(F) == 0:
        return F
    newF = []
    for FD in F:
        if oldFD == FD:
            newF.append(newFD)
        else:
            newF.append(FD)
    return newF

                
    
# 删除冗余属性 1. 删除 FD 的冗余属性 2. 取代旧的 FD

def minF(F):
    newF = []
    for FD in F:
        if len(FD[1].split(',')) > 1:
            newFDs = decompositionRule(FD)
            newF.extend(newFDs) 
        else:
            newF.append(FD)
    
    while True:
        nF = []
        for FD in newF:
            if not isDelFD(FD, newF):
                nF.append(FD)

        beforeF = nF
        for FD in nF:
            newFD = delRedundantAttr(nF, FD)
            if newFD != FD:
                nF = substituteEle(nF, FD, newFD)
        
        afterF = nF
        
        if beforeF == afterF:
            break

        newF = afterF
    print(afterF)
    # return newF

F = [
    ['A,B,H', 'C'],
    ['A', 'D'],
    ['C', 'E'],
    ['B,G,H', 'F'],
    ['F', 'A,D'],
    ['E', 'F'],
    ['B,H', 'E']
]

# minF(F)

def levelStr(n):
    myStr = '--'
    i = 0
    while i < n:
        myStr = myStr + '--'
        i = i + 1
    return myStr

def arr2Str(data):
    myStr = ''
    for x in data:
        if type(x) == list:
            inStr = '' 
            i = 0
            while i < len(x):
                inStr = inStr + '|' + x[i]
                i = i + 1
            myStr = myStr + ',' + '[' + inStr.strip('|') +']'
        else:
            myStr = myStr + ',' + x
    return '[' + myStr.strip(',') + ']'

# levelStr(0)
data = ['a', ['b', 'c'], ['dd'], 'd']

# re = arr2Str(data)
# print(re)
# permutation 排列
# combination 组合
def permutation(data, k, n):
    if k == 0 or len(data) == 0:
        return []
    result = []
    print("%s before input: data = %s, k = %d" % (levelStr(n), arr2Str(data), k))
    k = k - 1
    for ele in data:
        newData = [] 
        i = 0
        while i < len(data):
            if ele != data[i]:
               newData.append(data[i]) 
            i = i + 1
        re = permutation(newData, k, n + 1)
        if len(re) == 0:
            re.append(ele)
            result.append(re)
        else:
            path = []
            for x in re:
                path.append(x + ',' + ele)
            result.append(path)
    
    finalResult = []
    # print("%s after result: %s" % (levelStr(n), arr2Str(result)))
    # print(result)
    for x in result:
        i = 0
        while i < len(x):
            finalResult.append(x[i])
            i = i + 1
    # print(finalResult)
    # print("%s after finalResult: %s" % (levelStr(n), arr2Str(finalResult)))
    return finalResult



data = ['A', 'B', 'C', 'D', 'E'] 

# re  = permutation(data, 3, 0)
# print(re)

# a = [['a'],['b'],['c']]
# c = []
# for x in a:
#     c.append(x[0])
# print(c)

# result = [['B,A', 'C,A', 'D,A'], ['A,B', 'C,B', 'D,B'], ['A,C', 'B,C', 'D,C'], ['A,D', 'B,D', 'C,D']]
# ['B,A', 'A,B', 'A,C', 'A,D']

def combination(data, k, n):
    if k == 0 or len(data) == 0:
        return []
    result = []
    hasChosenEle = []
    k = k - 1
    # print("%s before input: data = %s, k = %d" % (levelStr(n), arr2Str(data), k))
    for ele in data:
        hasChosenEle.append(ele)
        i = 0
        newData = []
        while i < len(data):
            if data[i] != ele and data[i] not in hasChosenEle:
                newData.append(data[i])
            i = i + 1
        if k != 0 and len(newData) == 0:
            continue
        re = combination(newData, k, n + 1)
        if k == 0 and len(re) == 0:
            re.append(ele)
            result.append(re)
        else:
            path = []
            for x in re:
                path.append(x + ',' + ele)
            result.append(path)
    
    finalResult = []
    # print("%s after result: %s" % (levelStr(n), arr2Str(result)))
    # print(result)
    for x in result:
        i = 0
        while i < len(x):
            finalResult.append(x[i])
            i = i + 1
    # print(finalResult)
    # print("%s after finalResult: %s" % (levelStr(n), arr2Str(finalResult)))
    return finalResult
    

# data = ['A', 'B', 'C', 'D', 'E']
# data = ['A', 'B', 'C', 'D']
# re = combination(data, 3, 0)
# print(re)

def classifyAttr(U, F):
    U = set(U[0].split(','))
    allLeftPartAttrs = []
    allRightPartAttrs = []
    for FD in F:
        leftPartAttrs = FD[0].split(',')
        rightPartAttrs = FD[1].split(',')
        for leftAttr in leftPartAttrs:
            if leftAttr not in allLeftPartAttrs: 
                allLeftPartAttrs.append(leftAttr) 
           
        for rightAttr in rightPartAttrs:
            if rightAttr not in allRightPartAttrs:
                allRightPartAttrs.append(rightAttr)
    
    allLeftPartAttrsSet = set(allLeftPartAttrs)
    allRightPartAttrsSet = set(allRightPartAttrs)
    LR = allLeftPartAttrsSet.intersection(allRightPartAttrsSet)
    L = allLeftPartAttrsSet.difference(LR)
    R = allRightPartAttrsSet.difference(LR)
    N = U.difference(allLeftPartAttrsSet.union(allRightPartAttrsSet))
    return {
        'L': L,
        'R': R,
        'LR': LR,
        'N': N
    }

def removeEle(arr, ele):
    newArr = []
    for x in arr:
        if x != ele:
           newArr.append(x) 
    return newArr

def calculateCandidateKey(U, F):
    classifiedAttrs = classifyAttr(U, F)
    X = classifiedAttrs['L'].union(classifiedAttrs['N'])
    initAttrClosure = ''
    for x in X:
        initAttrClosure = initAttrClosure + ',' + x
    initAttrClosure = initAttrClosure.strip(',')
    closure = calculateAttrClosure(F,[initAttrClosure])

    U = set(U[0].split(','))
    if U.intersection(closure) == U:
        return [initAttrClosure]
    i = 1
    LRArr = list(classifiedAttrs['LR'])
    candidateKeys = []
    print(LRArr)
    while i <= len(LRArr):
        com = combination(LRArr, i, 0)
        print(com)
        for c in com:
            attrClosure = initAttrClosure + ',' + c
            print("init closure %s" % (attrClosure))
            closure = calculateAttrClosure(F, [attrClosure])
            print(closure)
            # print(U.intersection(closure) == U)
            if U.intersection(closure) == U:
                candidateKeys.append(attrClosure)
                for a in c.split(','):
                    LRArr = removeEle(LRArr, a)
        i = i + 1
        if len(LRArr) == 0:
            break

    return candidateKeys

# U = ['A,B,C,D']

# F = [
#     ['A', 'B,C'],
#     ['B,C', 'A'],
#     ['B,C,D', 'E,F'],
#     ['E', 'C']
# ]

U = ['A,B,C,D']
F = [
    ['A','C'],
    ['C','B'],
    ['A,D','B']
]

U = ['H,I,J,K,L,M']
F = [
    ['H','I'],
    ['K','I'],
    ['L,M','K'],
    ['I','K'],
    ['K,H','M']
]

# re = calculateCandidateKey(U, F)
# print(re)


# closure = {'E', 'F', 'A', 'D', 'C', 'B'}
# print()

# 传递律
def transitivity(F):
    needDel = []
    for FD in F:
        i = 0
        # determinant = FD[0]
        Y = FD[1]
        while i < len(F):
            print("F[i][0]: %s, Y: %s" %(F[i][0], Y))
            determinant = F[i][0]
            if determinant == Y:
                FD[1] = F[i][1]
                needDel.append(F[i])
            i = i + 1
        # newF.append(FD)
    
    # print(needDel)
    print(F)
    for delEle in needDel:
        F = removeEle(F, delEle)
    print(F)

F = [
    ['B','A'],
    ['D','A'],
    ['A','E'],
    ['A,C','B']
]

R1 = ['A,B,C,E']
R2 = ['C,D']
RList = [
    R1,
    R2
]

# transitivity(F)

def classifyF(F, R):
    RSet = set(R[0].split(','))
    classifiedF = []
    for FD in F:
        determinantSet = set(FD[0].split(','))
        YSet = set(FD[1].split(','))
        if determinantSet.issubset(RSet) and YSet.issubset(RSet):
            classifiedF.append(FD)
    return classifiedF

def calculateLeftPartClosure(F):
    closures = {}
    for FD in F:
        determinant = FD[0] 
        closure = list(calculateAttrClosure(F, [determinant]))
        closures[determinant] = closure
    return closures

def addHideFD(F):
    FList = F.copy()
    leftPartClosures = calculateLeftPartClosure(FList) 
    for determinant, closure in leftPartClosures.items():
        determinantArr = determinant.split(',')
        for attr in closure:
            if attr in determinantArr:
                # 平凡函数依赖
                continue
            hideFD = [determinant, attr]
            if hideFD not in FList:
                FList.append(hideFD)
    return FList

listA = ['A', 'B', 'C']        
listB = ['A', 'C', 'E', 'F']
# python 不支持用 set 函数将二维列表变成集合
def listDifference(listA, listB):
    # ListA 取 ListB 的差集
    differenceList = []
    for item in listA:
        if item not in listB:
            differenceList.append(item) 
    return differenceList
# re = listDifference(listA,listB)

# re = classifyF(F, R1)
# re = calculateLeftPartClosure(F)
# newF = addHideFD(F)
# re = classifyF(newF, R2)
# print(re)
# print(re)
# 输入原函数依赖集，以及关系列表 [R1, R2,..., Rn]
def isKeepFD(F,RList):
    print(F)
    newF = addHideFD(F)
    classifiedFList = []
    for R in RList:
        classifiedFList.append(classifyF(newF, R))
    
    G = []
    for classifiedF in classifiedFList:
        for FD in classifiedF:
            G.append(FD)
    differences = listDifference(F, G)
    if len(differences) == 0:
        return True
    
    for FD in differences:
        determinant = FD[0]
        closure = calculateAttrClosure(G, [determinant])
        print(closure)
        print(set(FD[1]))
        if not set([FD[1]]).issubset(closure):
            return False
    return True
re = isKeepFD(F, RList)
print(re)

```
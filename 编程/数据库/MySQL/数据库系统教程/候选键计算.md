---
aliases:
  - 候选键
date: 2025-06-15
---

# 目录

```dataviewjs
const startHeadinglevel = 2;
const file = app.workspace.getActiveFile();
const { headings } = app.metadataCache.getFileCache(file);
 
// 全列表的形式
const raws = headings.filter(row => row.heading != "目录").map( p => {
    let repeatCount = Math.max((p.level - startHeadinglevel) * 4, 0);
    let spacesPrefix = ' '.repeat( repeatCount + 4 );
    let listSign = repeatCount > 0 ? '- ' : '';
    let linkText = `[[#${p.heading}]]`;
    let headingList = (p.level < startHeadinglevel) ? `- ${linkText}` : `${spacesPrefix}- ${linkText}`;
    return headingList;
  }
)
 
let result = raws.join('\n');
// 添加行距
dv.container.style.lineHeight = "1.5em";
dv.paragraph(result)
```

 **算法描述**

    1.给定关系模式R（U，F）。将R的所有属性分为L，R，LR和N四类。其中

        L表示属性只在函数依赖左边出现；

        R表示属性只在函数依赖右边出现；

        LR表示属性既在左边出现，又在右边出现；

        N表示函数依赖左右都未出现。  

    2.令X = L ∪ N，Y=LR。求X的闭包，若X的闭包包含了R的所有属性，**则X为R的唯一候选码**，转（5）。  

    3.  Y中选取任意一个属性A，求（XA）的闭包，若它包含了R的全部属性，则是候选码。调换属性，反复进行这个过程，直到试完Y中的所有属性。

    4.如果已找出所有的候选码，转（5），否则在Y中依次选取2个属性，3个属性，...，求他们的闭包。若其闭包包含R的全部属性，则是候选码。  

    5.结束算法，输出候选码  

  

***注：看算法描述感觉很复杂，其实很简单。不妨先看看以下的例子。**

例：关系模式R（A,B,C,D），函数依赖F={A→BC,BC→A,BCD→EF,E→C}，求R的候选码。

  

**解：**

        **1.首选找出L,R,LR,N**

                    只在函数依赖左边出现 L={D}

                    只在函数依赖右边出现R={F}  

                    在函数依赖左右边都出现 LR={A,B,C,E}  

                    函数依赖左右边都未出现 N={ }  

        **2.令X，判断是否是唯一候选码**  

                    令X=L ∪ N ={D}，则X={D}，故D的闭包D+ = {D}。因此不是候选码  

        **3.在LR中选取元素**  

                     1.选取A，则(AD)+ ={A,D,B,C,E,F}  与R相同，故AD是候选码  

                     2.选取B，则(BD)+={B,D}，显然与R不同，故BD不是候选码  

                    3.选取C，则(CD)+={C,D}，显然与R不同，故CD不是候选码  

                    4.选取E，则(ED)+={D,E,C}，显然与R不同，故ED不是候选码  

        **4.因此，在LR中，使用了属性A，还剩下属性{B,C,E}未使用。**  

                    1.选取BC，则（BCD)+={D,B,C,E,F,A} 与R相同，故BCD是候选码  

                    2.选取BE，则（BED)+={D,B,E,C,A,F}与R相同，故BDE是候选码  

                    3.选取CE，则（CED)+={D,C,E}，显然与R不同，故CED不是候选码。  

        此时，LR中无剩余属性【也可以理解为，LR中无新的属性组合（**注意理解什么是候选键**）】。  

        **5.算法结束**  

        综上所述，输出的候选键为 DA,DBC和DBE。

  
------------------------------------  
作者：程俊伟  
来源：学者网  
原文：https://www.scholat.com/vpost.html?pid=142356  
本文为该学者原创文章，转载请附上文章链接！

# 原理



---

### **候选码求解方法论**

---

#### **一、算法步骤**
1. **属性分类**  
   - **L类**：只出现在函数依赖左侧的属性  
   - **R类**：只出现在右侧的属性  
   - **LR类**：左右均出现的属性  
   - **N类**：左右均未出现的属性  

2. **必选规则**  
   - L类和N类属性**必须包含**在候选码中  
   - LR类和R类属性依依赖关系动态判定  

3. **闭包验证**  
   从必选属性出发，逐步添加其他属性并计算闭包，若闭包包含全体属性则为候选码。

---

#### **二、核心原理**  

- 候选码是**极小的超键**，其闭包覆盖所有属性。若闭包未覆盖全体属性，则需要添加属性直至满足闭包条件。
- 将关系模式 R(U,F) 的属性分为四类。L 类属性（仅出现在函数依赖左边）、R 类属性（仅出现在函数依赖右边）、LR 类属性（在函数依赖左右两边都出现）、N 类属性（在函数依赖两边都不出现）。
	- L 类和 N 类属性一定是候选码的一部分。
	- R 类属性一定不是候选码的一部分。
	- 对 LR 类属性，通过计算其闭包来判断是否为候选码。

---

#### **三、经典示例**
**场景**：关系模式 `R(A,B,C,D)`，函数依赖集 `{A→B, B→C, D→B}`  

1. **属性分类**  
   - L类：A, D（只在左侧出现）  
   - R类：C（只在右侧出现）  
   - LR类：B（左右均出现）  

2. **必选属性**：A和D必须包含  

3. **验证候选码**：
   - 计算 `AD` 的闭包：  
     `AD → A, D → ADB (B→C) → ADBC` （覆盖全部属性）  
   - 检查是否存在更简组合：  
     `A` 的闭包：A→B→C → `ABC`（未覆盖D）→ 需加入D  
   ⇒ **唯一候选码**：`AD`  

---

#### **四、验证技巧**  
- **极小性测试**：若从候选码中删去任一属性后闭包不再覆盖全体属性，则为候选码  
- **多重候选码**：可能存在多个候选码（如学号、身份证号均可作为学生表候选码）  

--- 

✔️ **总结**：通过属性分类确定必选项，闭包验证覆盖性，剔除冗余属性得到候选码。
---
aliases:
  - 最小函数依赖
date: 2025-06-15
---

# 目录

```dataviewjs
const startHeadinglevel = 2;
const file = app.workspace.getActiveFile();
const { headings } = app.metadataCache.getFileCache(file);
 
// 全列表的形式
const raws = headings.filter(row => row.heading != "目录").map( p => {
    let repeatCount = Math.max((p.level - startHeadinglevel) * 4, 0);
    let spacesPrefix = ' '.repeat( repeatCount + 4 );
    let listSign = repeatCount > 0 ? '- ' : '';
    let linkText = `[[#${p.heading}]]`;
    let headingList = (p.level < startHeadinglevel) ? `- ${linkText}` : `${spacesPrefix}- ${linkText}`;
    return headingList;
  }
)
 
let result = raws.join('\n');
// 添加行距
dv.container.style.lineHeight = "1.5em";
dv.paragraph(result)
```

# 定义
极小函数依赖集是指在保持函数依赖关系不变的情况下，通过删除冗余的依赖和属性，使得依赖集达到最简形式。具体来说，极小函数依赖集 F<sub>min</sub>​ 满足以下三个条件：

无冗余依赖：每个依赖 X→Y 都是必要的，即从 F<sub>min</sub>​ 中去掉任何一个依赖都会改变依赖集的闭包。
[[右部单一化|右部单属性]]：每个依赖的右部都是单个属性。
左部无冗余属性：每个依赖的左部没有多余的属性，即去掉左部的任何属性都会改变依赖。

# 作用

简化数据库设计：减少冗余，提高数据存储效率。
优化查询性能：更简洁的依赖集有助于索引和查询优化。
范式分解：帮助识别和消除冗余依赖，确保数据库满足更高范式（如3NF、BCNF）。

# 示例演示
原始依赖集：
F={A→BC, B→D, AC→E, A→E}
步骤1：右部单属性化
将每个依赖的右部拆分为单个属性：
F1​={A→B, A→C, B→D, AC→E, A→E}
步骤2：删除冗余依赖
检查每个依赖是否可以被其他依赖推导出来：

A→E 可以由 A→C 和 AC→E 推导出，因此可以删除 A→E。
其他依赖均不能被其他依赖推导出来。

得到新的依赖集：
F2​={A→B, A→C, B→D, AC→E}
步骤3：左部无冗余属性
检查每个依赖的左部是否有冗余属性：

A→B 和 A→C 的左部无冗余。
B→D 的左部无冗余。
AC→E 的左部无冗余（因为 A→E 已经被删除）。

最终极小函数依赖集：
F<sub>min</sub>​={A→B, A→C, B→D, AC→E}
# 总结
极小函数依赖集通过删除冗余依赖和属性，使得依赖集达到最简形式，从而简化数据库设计、优化查询性能，并帮助进行范式分解。上述示例展示了如何从原始依赖集逐步转换为极小函数依赖集。

# 实际例子

## 示例背景

假设有一个学生选课数据库，包含以下字段：

- Sno（学号）
- Sname（姓名）
- Sdept（所在院系）
- Mname（院系主任）
 - Cno（课程号）
- Grade（成绩）


## 原始函数依赖集
初始设计时存在以下函数依赖：

```
F={Sno→Sname, Sno→Sdept, Sno,Sname→Sdept, Sdept→Mname, Sno,Cno→Grade}
```

## 极小化过程

### 拆分右部为单属性

原依赖右部均为单属性，无需拆分。

### 删除冗余依赖

检查发现 Sno→Sdept 已经成立，而 Sno, Sname→Sdept 的左侧存在冗余（Sname 不必要），因此删除后者的冗余依赖。

### 简化左部冗余属性

依赖 Sno, Cno→Grade 中的左部无冗余，因一个学生的成绩需由学号和课程号共同确定，无法仅由 Sno 或 Cno 单独推导。

## 极小函数依赖集
最终极小函数依赖集为：

```
Fmin​={Sno→Sname, Sno→Sdept, Sdept→Mname, Sno, Cno→Grade}
```

验证条件

右部单属性：每个依赖右部仅含一个属性（如 Sname、Sdept）。
无冗余依赖：

若删除 Sno→Sdept，无法通过其他依赖推导出院系信息。
若删除 Sdept→Mname，无法通过学号直接关联院系主任。


左部不可约简：

Sno, Cno→Grade 中的 Sno 和 Cno 缺一不可，无法简化。

## 实际应用意义

### 数据库表结构设计

```Sql
学生表（Students）：sql复制CREATE TABLE Students (
  Sno INT PRIMARY KEY,
  Sname VARCHAR(20),
  Sdept VARCHAR(30),
  Mname VARCHAR(20),
  FOREIGN KEY (Sdept) REFERENCES Departments(Sdept)
);


成绩表（Grades）：sql复制CREATE TABLE Grades (
  Sno INT,
  Cno VARCHAR(10),
  Grade INT,
  PRIMARY KEY (Sno, Cno),
  FOREIGN KEY (Sno) REFERENCES Students(Sno)
);
```


### 查询优化

通过极小依赖确定关键字段，例如仅需索引 Sno 即可快速访问学生院系和姓名，无需额外冗余索引。

### 数据一致性维护：

添加学生时，若违反 Sno→Sname（同一学号对应不同姓名），系统将抛出错误。

## 极端场景
若原始依赖包含[[隐式冗余]]：

原始依赖：Sno→Mname（冗余，因已存在 Sno→Sdept→Mname）
极小化处理：删除 Sno→Mname，保留 Sdept→Mname，避免数据更新异常（如院系更换主任时需多处修改）。


通过这个例子，可直观理解极小函数依赖集如何精简约束规则，同时确保数据完整性和操作效率。

# 算法



[重录版(更详细)_哔哩哔哩_bilibili# 数据库系统概论——最小函数依赖集计算](https://www.bilibili.com/video/BV1pE411P7ab?spm_id_from=333.788.videopod.episodes&vd_source=081641abeed94aff322f0473e2c1773d&p=2)


算法：  

1.     用分解的法则，使F中的任何一个函数依赖的右边仅含一个属性
    
2.     去除多余的**函数依赖**：从第一个函数依赖X→Y开始，将其从F中去掉，然后在剩下的函数依赖中求X的闭包X+，判断X+是否包含Y，如果包含，则去掉X→Y，否则保留，依次做下去，直到扫描所有函数依赖为止。
    
3.     去掉依赖左侧多余的**冗余属性**：如XY→A，若要判断Y是冗余属性，则计算X+，判断A是否属于X+，如果属于，则Y是冗余属性，将其删除，同理判断X。
    

   **注意：若在第三步中修改了函数依赖集F，则需要重新做一次步骤二。**

例： R={A,B,C,D,E,G}，F={B→D,DG→C,BD→E,AG→B,ADG→BC}，求F的最小函数依赖

  

解：

1. 运用分解律，进行拆除
    
    F={B→D,DG→C,BD→E,AG→B,ADG→B,ADG→C}
    
2. 判断冗余的函数依赖
    
    1.假设删除B→D，则B+={B}，故保留
    
    2.假设删除DG→C，则(DG)+={D,G}，故保留
    
    3.假设删除BD→E，则（BD)+={B,D}，故保留
    
    4.假设删除AG→B，则（AG)+={A,G}，故保留
    
    5.假设删除ADG→B，则(ADG)+={A,D,G,C,B,E}，有B，删除
    
    6.假设删除ADG→C，则（ADG)+={A,D,G,B,E,C}，有C，删除
    
    综上，F更新为
    
    F={B→D,DG→C,BD→E,AG→B}
    
3. 判断左侧的冗余属性，DG→C,BD→E,AG→B，左侧的属性个数大于1，故进行判断是否冗余
    
    1.看DG→C，假设删除D，则G+={G}，假设删除G，则D+={D}，无C，保留
    
    2.看BD→E，假设删除B，则D+={D}，假设删除D，则B+={B，D，E}，有E，则删除D，得到B→E
    
    3.看AG→B，假设删除A，则G+={G}，假设删除G，则A+={A}，无B，保留。
    
    综上，F更新为
    
    F={B→D,DG→C,B→E,AG→B}
    
4. 由于步骤3更新了F，故在进行一次步骤2.
    
    1.假设删除B→D,显然B的闭包不包含D
    
    2.假设删除DG→C，显然DG的闭包不包含C
    
    3.假设删除B→E，显然B的闭包不包含E。
    
    4.假设删除AG→B，显然AG的闭包不包含B。
    

综上所述最小依赖集为F={B→D,DG→C,B→E,AG→B}。

**注：最小依赖集不唯一。**

  
------------------------------------  
作者：程俊伟  
来源：学者网  
原文：https://www.scholat.com/vpost.html?pid=142239  
本文为该学者原创文章，转载请附上文章链接！
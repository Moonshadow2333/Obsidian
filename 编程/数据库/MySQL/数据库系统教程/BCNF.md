---
aliases:
  - 关系模式
date: 2025-06-13
---

# 目录

```dataviewjs
const startHeadinglevel = 2;
const file = app.workspace.getActiveFile();
const { headings } = app.metadataCache.getFileCache(file);
 
// 全列表的形式
const raws = headings.filter(row => row.heading != "目录").map( p => {
    let repeatCount = Math.max((p.level - startHeadinglevel) * 4, 0);
    let spacesPrefix = ' '.repeat( repeatCount + 4 );
    let listSign = repeatCount > 0 ? '- ' : '';
    let linkText = `[[#${p.heading}]]`;
    let headingList = (p.level < startHeadinglevel) ? `- ${linkText}` : `${spacesPrefix}- ${linkText}`;
    return headingList;
  }
)
 
let result = raws.join('\n');
// 添加行距
dv.container.style.lineHeight = "1.5em";
dv.paragraph(result)
```

# 概念理解

在一个关系模式的非平凡函数依赖中，如果所有决定子都含有键（即决定子是超键），则此关系属于 BCNF

在关系数据库中，BCNF（Boyce - Codd 范式）是一种更高程度的规范化形式，用于消除关系模式中可能存在的某些数据冗余和更新异常问题。在非平凡函数依赖中，如果所有决定子（即函数依赖左边的属性集合）都含有键（候选键），那么这个关系模式就属于 BCNF。非平凡函数依赖指的是$X→Y$，且$Y$不是$X$的子集。

### 原理分析
- **数据完整性与一致性**：当所有决定子都含有键时，说明每个非平凡函数依赖都是由键来决定其他属性的。键具有唯一性，这就保证了数据的完整性和一致性。例如，在学生表中，学号是键，通过学号可以唯一确定学生的姓名、年龄等信息。如果一个函数依赖的决定子不是键，可能会出现数据不一致的情况，比如通过非键属性确定学生的班级，当该非键属性值重复时，就可能导致班级信息的混乱。
- **消除部分依赖和传递依赖**：BCNF 的核心目标是消除部分依赖和传递依赖。部分依赖是指非主属性部分依赖于候选键的一部分；传递依赖是指非主属性通过其他非主属性间接依赖于候选键。当所有决定子都含有键时，就不存在部分依赖和传递依赖，因为每个决定子都能唯一标识元组，不会出现属性依赖于键的一部分或者通过其他非键属性来确定的情况。
- **数据更新的正确性**：由于决定子都是键，在进行数据更新（插入、删除、修改）操作时，不会因为函数依赖的问题而产生异常。例如，如果一个关系模式中存在非键决定子的函数依赖，在删除某个元组时，可能会导致一些有用的信息丢失。而在 BCNF 关系模式中，因为键决定一切，更新操作只会影响与键相关的元组，不会破坏数据的完整性。

### 具体示例
假设有一个关系模式`R(学号, 课程号, 成绩, 教师姓名, 教师办公室)`，并且存在以下函数依赖：
- `(学号, 课程号) → 成绩`
- `课程号 → 教师姓名`
- `教师姓名 → 教师办公室`

在这个关系模式中，候选键是`(学号, 课程号)`。可以看到，函数依赖`课程号 → 教师姓名`和`教师姓名 → 教师办公室`的决定子`课程号`和`教师姓名`都不是键，所以该关系模式不属于 BCNF。

为了将其转换为 BCNF，可以将关系模式分解为：
- `R1(学号, 课程号, 成绩)`，候选键是`(学号, 课程号)`，函数依赖`(学号, 课程号) → 成绩`的决定子是键，满足 BCNF。
- `R2(课程号, 教师姓名)`，候选键是`课程号`，函数依赖`课程号 → 教师姓名`的决定子是键，满足 BCNF。
- `R3(教师姓名, 教师办公室)`，候选键是`教师姓名`，函数依赖`教师姓名 → 教师办公室`的决定子是键，满足 BCNF。

通过这样的分解，每个关系模式都满足 BCNF 的要求，消除了可能存在的数据冗余和更新异常问题。 

# 如何判断 BC  范式

看函数依赖的左侧是否都为候选键？

- 如果是，则是 BC 范式
- 如果不是，则不是 BC 范式
---
aliases:
  - 函数依赖
date: 2025-06-09
---

# 目录

```dataviewjs
const startHeadinglevel = 2;
const file = app.workspace.getActiveFile();
const { headings } = app.metadataCache.getFileCache(file);
 
// 全列表的形式
const raws = headings.filter(row => row.heading != "目录").map( p => {
    let repeatCount = Math.max((p.level - startHeadinglevel) * 4, 0);
    let spacesPrefix = ' '.repeat( repeatCount + 4 );
    let listSign = repeatCount > 0 ? '- ' : '';
    let linkText = `[[#${p.heading}]]`;
    let headingList = (p.level < startHeadinglevel) ? `- ${linkText}` : `${spacesPrefix}- ${linkText}`;
    return headingList;
  }
)
 
let result = raws.join('\n');
// 添加行距
dv.container.style.lineHeight = "1.5em";
dv.paragraph(result)
```

# 定义
传递函数依赖（Transitive Functional Dependency）指在关系模式中，存在属性集合 A、B 和 C，满足以下条件：

A → B：属性集合 A 唯一确定 B。
B → C：属性集合 B 又唯一确定 C。
A ↛ C（直接）：C 并不直接依赖于 A，而是通过 B 的传递形成依赖。
此时，称 C 传递依赖于 A，记作 A → C（传递）。


# 产生原因
传递函数依赖通常出现在 未规范化的数据库设计 中，尤其在以下场景：

表结构冗余：非主属性依赖于其他非键属性，而非直接依赖于候选键。
设计缺陷：未将实体和属性合理分解，导致中间属性成为传递链的中介。


---

传递函数依赖通常出现在以下情况：

数据逻辑关联：某些属性通过中间属性间接相关。
非范式化设计：表结构设计不合理，导致数据冗余和不一致性。


### 传递函数依赖

#### 定义
**传递函数依赖**（Transitive Functional Dependency）是指在关系模式中，如果存在 \( X \rightarrow Y \) 和 \( Y \rightarrow Z \)，且 \( Y \not\subseteq X \) 且 \( Z \not\subseteq Y \)，那么 \( X \rightarrow Z \) 是一个传递函数依赖。

---

#### 为什么会出现传递函数依赖
传递函数依赖通常出现在以下情况：
1. **数据逻辑关联**：某些属性通过中间属性间接相关。
2. **非范式化设计**：表结构设计不合理，导致数据冗余和不一致性。

---

#### 具体例子

**背景**：假设有一个学生选课系统，包含以下字段：
- **Sno**（学号）
- **Sdept**（所在院系）
- **Mname**（院系主任）

**原始依赖集**：

```
F={Sno→Sdept, Sdept→Mname}
```

**分析**：
 **直接依赖**：  
- Sno→Sdept：学号决定所在院系。
- Sdept→Mname：所在院系决定院系主任。

 **传递依赖**：  
- 由于 Sno→Sdept 和 Sdept→Mname，可以推导出 Sno→Mname。
- 即学号通过所在院系间接决定了院系主任。

**具体例子**：
- **学生表**：

  | Sno  | Sdept  | Mname  |
  |------|--------|--------|
  | 001  | CS     | 张三   |
  | 002  | CS     | 张三   |
  | 003  | Math   | 李四   |

- **解释**：
  - 学号 001 和 002 都在 CS 院系，因此他们的院系主任都是张三。
  - 学号 003 在 Math 院系，因此他的院系主任是李四。

---

#### 问题与解决方案

**问题**：
- **更新异常**：如果某个院系的主任更换了，需要修改所有该院系学生的记录。
- **数据冗余**：院系主任的名字在每个学生记录中重复存储。

**解决方案**：
- **分解表结构**：将表分解为两个表，消除传递依赖。
  - **学生表 (Students)**：
    ```sql
    CREATE TABLE Students (
      Sno INT PRIMARY KEY,
      Sdept VARCHAR(30)
    );
    ```
  - **院系表 (Departments)**：
    ```sql
    CREATE TABLE Departments (
      Sdept VARCHAR(30) PRIMARY KEY,
      Mname VARCHAR(20)
    );
    ```

- **通过外键关联**：
  ```sql
  ALTER TABLE Students
  ADD FOREIGN KEY (Sdept) REFERENCES Departments(Sdept);
  ```

**优化后的表结构**：
- **学生表 (Students)**：

  | Sno | Sdept |
  | --- | ----- |
  | 001 | CS    |
  | 002 | CS    |
  | 003 | Math  |

- **院系表 (Departments)**：

  | Sdept  | Mname  |
  |--------|--------|
  | CS     | 张三   |
  | Math   | 李四   |

---

通过分解表结构，消除了传递依赖，减少了数据冗余，并提高了数据的一致性和维护性。
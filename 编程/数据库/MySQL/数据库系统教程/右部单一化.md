---
aliases:
  - 数据库
  - 函数依赖
date: 2025-06-09
---

# 目录

```dataviewjs
const startHeadinglevel = 2;
const file = app.workspace.getActiveFile();
const { headings } = app.metadataCache.getFileCache(file);
 
// 全列表的形式
const raws = headings.filter(row => row.heading != "目录").map( p => {
    let repeatCount = Math.max((p.level - startHeadinglevel) * 4, 0);
    let spacesPrefix = ' '.repeat( repeatCount + 4 );
    let listSign = repeatCount > 0 ? '- ' : '';
    let linkText = `[[#${p.heading}]]`;
    let headingList = (p.level < startHeadinglevel) ? `- ${linkText}` : `${spacesPrefix}- ${linkText}`;
    return headingList;
  }
)
 
let result = raws.join('\n');
// 添加行距
dv.container.style.lineHeight = "1.5em";
dv.paragraph(result)
```

任一函数依赖集 F 总可以为一右部恒为单属性的函数依赖集所覆盖

# 原理与示例：将任意函数依赖集转换为右部为单属性的函数依赖集

#### 一、原理解析
**定义**：给定一个函数依赖集 \( F \)，我们总可以找到另一个函数依赖集 \( F' \)，使得 \( F' \) 的每个依赖的右部都是单个属性，并且 \( F \) 和 \( F' \) 在逻辑上是等价的。

**核心思想**：通过分解多属性的右部，将其拆分成多个单属性的右部，从而确保每个依赖的右部都是单个属性。


步骤：

遍历原始依赖集 F 中的每一个依赖 X→Y。
分解右部：如果 Y 包含多个属性（即 Y={Y1​,Y2​,…,Yn​}），则将 X→Y 分解为 n 个依赖 X→Y1​,X→Y2​,…,X→Yn​。
构造新依赖集 F′：将所有分解后的依赖加入 F′。

数学表达：

原始依赖集 F={X→Y1​,X→Y2​,…,X→Ym​}
新依赖集 F′={X→Y11​,X→Y12​,…,X→Y1n<sub>1</sub>​,X→Y21​,…,X→Ym1​,…,X→Ymn<sub>m</sub>​​}

其中 Yi​={Yi1​,Yi2​,…,Yin<sub>i</sub>​​}。

#### 二、典型示例

**示例1：基础学生信息表**

**原始依赖集** \( F \)：
- {学号} → {姓名, 专业}
- {学号, 课程} → {成绩}

**分解过程**：
1. 对于 {学号} → {姓名, 专业}：
   - 分解为 {学号} → {姓名} 和 {学号} → {专业}
2. 对于 {学号, 课程} → {成绩}：
   - 右部已经是单属性，无需分解

**新依赖集** \( F' \)：
- {学号} → {姓名}
- {学号} → {专业}
- {学号, 课程} → {成绩}

---

**示例2：复杂员工信息表**

**原始依赖集** \( F \)：
- {工号} → {姓名, 部门, 职位}
- {部门, 职位} → {工资, 福利}
- {工号, 项目} → {项目名称, 项目状态}

**分解过程**：
1. 对于 {工号} → {姓名, 部门, 职位}：
   - 分解为 {工号} → {姓名}，{工号} → {部门}，{工号} → {职位}
2. 对于 {部门, 职位} → {工资, 福利}：
   - 分解为 {部门, 职位} → {工资}，{部门, 职位} → {福利}
3. 对于 {工号, 项目} → {项目名称, 项目状态}：
   - 分解为 {工号, 项目} → {项目名称}，{工号, 项目} → {项目状态}

**新依赖集** \( F' \)：
- {工号} → {姓名}
- {工号} → {部门}
- {工号} → {职位}
- {部门, 职位} → {工资}
- {部门, 职位} → {福利}
- {工号, 项目} → {项目名称}
- {工号, 项目} → {项目状态}

---

### 三、工程应用价值

#### 1. 依赖极小化
- **简化依赖集**：将多属性右部分解为单属性右部，有助于识别和消除冗余依赖。
- **示例**：  
  原始依赖集 \( F = \{{A, B} → {C, D}, {A, B} → {E}\} \)  
  分解后 \( F' = \{{A, B} → {C}, {A, B} → {D}, {A, B} → {E}\} \)  
  进一步检查 \( F' \) 是否存在冗余依赖。

#### 2. 数据库规范化
- **范式分解**：在进行BCNF或3NF分解时，需要确保每个依赖的右部为单属性，以避免传递依赖。
- **示例**：  
  原始依赖集 \( F = \{{A} → {B, C}, {B} → {D}\} \)  
  分解后 \( F' = \{{A} → {B}, {A} → {C}, {B} → {D}\} \)  
  根据 \( F' \) 进行范式分解。

#### 3. 查询优化
- **索引设计**：单属性右部更易于设计和维护索引，提高查询性能。
- **示例**：  
  原始依赖集 \( F = \{{A} → {B, C}\} \)  
  分解后 \( F' = \{{A} → {B}, {A} → {C}\} \)  
  可以分别对 \( B \) 和 \( C \) 设计索引。

---

### 四、常见误区警示

#### 误区1：误认为分解会改变依赖关系
- **正确理解**：分解后的依赖集 \( F' \) 与原始依赖集 \( F \) 在逻辑上是等价的，不会改变依赖关系的本质。

#### 误区2：忽略右部为空的情况
- **特殊情况**：若右部为空集，则该依赖无效，可以直接忽略。
- **示例**：  
  {A} → {} 是无效依赖，可以直接删除。

---

通过理解和应用这一原理，数据库设计者能够更好地管理和优化函数依赖集，确保数据库结构的合理性和高效性。
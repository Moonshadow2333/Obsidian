---
aliases:
  - JS
  - 函数
  - Javascript
date: 2025-04-06
---

# 目录

```dataviewjs
const startHeadinglevel = 2;
const file = app.workspace.getActiveFile();
const { headings } = app.metadataCache.getFileCache(file);
 
// 全列表的形式
const raws = headings.filter(row => row.heading != "目录").map( p => {
    let repeatCount = Math.max((p.level - startHeadinglevel) * 4, 0);
    let spacesPrefix = ' '.repeat( repeatCount + 4 );
    let listSign = repeatCount > 0 ? '- ' : '';
    let linkText = `[[#${p.heading}]]`;
    let headingList = (p.level < startHeadinglevel) ? `- ${linkText}` : `${spacesPrefix}- ${linkText}`;
    return headingList;
  }
)
 
let result = raws.join('\n');
// 添加行距
dv.container.style.lineHeight = "1.5em";
dv.paragraph(result)
```

# 什么是回调函数

在 JavaScript 中，**回调函数**（callback function）是指作为参数传递给另一个函数并在某个时刻被调用的函数。这种机制允许你在异步操作完成时或特定事件发生时执行代码，使得 JavaScript 能够处理非阻塞操作。

基本概念
- 回调函数：一个作为参数传递给其他代码的函数，并在某些操作完成后或特定条件下被执行。
- 高阶函数：接受一个或多个函数作为输入或者输出一个函数的函数。使用回调函数的函数通常是高阶函数。

```js
function greet(name, callback) {
    console.log('Hello, ' + name);
    callback();
}

// 定义回调函数
function sayGoodbye() {
    console.log('Goodbye!');
}

// 使用回调函数
greet('Alice', sayGoodbye);
// 输出:
// Hello, Alice
// Goodbye!
```

# 相关问题

- 为什么回调函数可以实现[[异步]]?

![[事件循环#事件和回调函数[ 2]]]

# 例子

```js
function A(fun){
    fun();
    console.log('~~A~~');
}

function B(fun){
    setTimeout(fun,1000);
    console.log('~~B~~');
}

function C(func){
   func();
   console.log('~~C~~');
}

function D(func){
    func();
    console.log('~~D~~');
}

function E(){
     console.log('~~E~~');
}

A(function(){
    B(function(){
        C(function(){
            D(function(){
                E();
            });
        });
    });
});
```

分析

这段JavaScript代码演示了同步和异步回调的执行顺序，重点在于`setTimeout`导致的延迟效果。以下是代码的总结：

### 函数定义：
1. **A(fun)**：立即执行传入的回调`fun`，然后打印`~~A~~`。
2. **B(fun)**：通过`setTimeout`延迟1秒执行`fun`，然后立即打印`~~B~~`。
3. **C(func)**：立即执行`func`，然后打印`~~C~~`。
4. **D(func)**：立即执行`func`，然后打印`~~D~~`。
5. **E()**：直接打印`~~E~~`。

### 调用流程：
```javascript
A(() => {
  B(() => {
    C(() => {
      D(() => {
        E();
      });
    });
  });
});
```

### 执行顺序分析：
1. **同步执行**：
   - 调用`A`，立即执行其回调（调用`B`）。
   - `B`设置`setTimeout`（异步），然后打印`~~B~~`。
   - `A`继续执行，打印`~~A~~`。
   
   **输出**：
   ```
   ~~B~~
   ~~A~~
   ```

2. **异步执行**（1秒后）：
   - `setTimeout`回调触发，调用`C`。
   - `C`执行回调（调用`D`），`D`执行回调（调用`E`）。
   - `E`打印`~~E~~`，随后`D`和`C`依次打印。
   
   **输出**：
   ```
   ~~E~~
   ~~D~~
   ~~C~~
   ```

### 关键点：
- **异步与同步混合**：`B`中的`setTimeout`将回调推迟，导致后续代码（`C/D/E`）延迟执行。
- **回调地狱**：多层嵌套回调使代码难以阅读和维护。
- **输出顺序**：同步代码（`B`和`A`）优先执行，异步代码（`E`、`D`、`C`）在1秒后按顺序执行。

### 总结：
代码展示了JavaScript事件循环机制中同步任务优先于异步任务执行的特点，同时凸显了回调嵌套带来的复杂性。通过`setTimeout`，`B`的回调被推迟，而其他函数（`A/C/D`）的同步执行导致日志顺序与代码结构不一致。这种模式常见于异步操作，但也提示了使用现代异步处理方式（如Promise/async-await）的必要性。

# 在回调函数中返回回调函数

阅读代码时看到了这种模式，想要理解其背后的机制。

此外，用户可能对如何组织代码、控制执行顺序或处理异步操作有疑问。

这里的每个中间件接收一个$next函数，并在内部调用它，从而形成嵌套的执行顺序

然后，我需要解释回调函数返回回调函数的概念。这可能涉及到闭包、高阶函数、中间件链、洋葱模型等概念。需要举例说明，比如中间件处理请求时的前置和后置操作，或者如何通过返回函数来实现延迟执行或链式调用。
同时，用户可能对为什么需要返回回调函数感兴趣。例如，在中间件模式中，每个中间件需要包装下一个中间件，从而形成一个执行链。返回回调允许将控制权传递给下一个中间件，同时保留当前中间件的上下文，以便在后续处理中执行后置逻辑。
另外，用户可能想了解这种模式的优势和适用场景。比如，在Web框架中处理请求和响应，或在异步编程中管理复杂的流程。需要指出这种模式如何提高代码的可维护性、灵活性和可扩展性。
还要考虑可能的误区。例如，闭包和作用域的管理，递归的终止条件，以及执行顺序是否正确。用户可能在实现时遇到问题，比如中间件没有按预期顺序执行，或者变量作用域导致的错误，这时候需要解释如何正确使用闭包和递归。



在回调函数中返回另一个回调函数是一种高阶函数（Higher-Order Function）的设计模式，常用于构建异步流程控制、中间件链式调用或延迟执行逻辑。以下是这种模式的核心原理和应用场景分析：

---

### 一、核心原理
1. **闭包嵌套**
   - 外层回调函数通过返回新的函数，将执行权交给调用方，形成延迟执行（Lazy Evaluation）
   - 内层函数可以访问外层作用域的变量（闭包特性）

2. **执行控制权传递**
   ```javascript
   function outer(callback) {
     return function inner() {
       // 在此处决定何时调用原始回调
       return callback();
     };
   }
   ```

---

### 二、典型应用场景

#### 1. 中间件洋葱模型（如Koa.js）
```javascript
// 中间件定义
app.use(async (ctx, next) => {
  console.log('Before next');
  await next(); // 触发下一个中间件
  console.log('After next'); // 后续逻辑
});

// 底层实现核心
function compose(middlewares) {
  return (ctx) => {
    const dispatch = (i) => () => {
      if (i >= middlewares.length) return;
      const middleware = middlewares[i];
      return middleware(ctx, dispatch(i + 1));
    };
    return dispatch(0)();
  };
}
```

#### 2. 链式异步验证
```javascript
function validateField(field) {
  return (next) => (data) => {
    if (data[field].valid) {
      return next(data); // 传递到下一个验证
    }
    throw new Error(`${field} invalid`);
  };
}

// 组合验证链
const validate = [validateField('name'), validateField('email')]
  .reduce((chain, fn) => fn(chain), (data) => data);
```

#### 3. 请求拦截器
```javascript
function createInterceptor() {
  let chain = Promise.resolve();

  return {
    add(fn) {
      chain = chain.then(() => fn(request => {
        // 返回下一个拦截器的处理函数
        return next(request);
      }));
    },
    execute(request) {
      return chain;
    }
  };
}
```

---

### 三、技术优势
1. **延迟执行**  
   通过返回函数而非直接执行，控制权交给调用方决定触发时机

2. **动态组合**  
   允许运行时动态拼接处理逻辑（如中间件的灵活增减）

3. **执行上下文保留**  
   闭包特性可保留父级作用域的变量状态

4. **异步控制**  
   结合Promise可轻松实现`async/await`流程管理

---

### 四、实现要点
1. **终止条件**  
   必须明确递归或链式调用的终止点（如Koa中的`next()`边界判断）

2. **作用域管理**  
   注意闭包变量的生命周期，避免内存泄漏

3. **错误边界**  
   需统一处理嵌套回调中的异常传递

---

### 五、反模式警示
```javascript
// 错误示例：未正确处理返回层级
function badMiddleware() {
  return (next) => {
    next(); // 直接执行而非返回函数
    return 'done';
  };
}

// 正确写法
function goodMiddleware() {
  return (next) => (args) => { // 返回函数层级
    const result = next(args);
    return process(result);
  };
}
```

---

这种模式本质上是通过 **函数组合（Function Composition）** 和 **闭包（Closure）** 实现的管道式控制流，在中间件系统、验证链、拦截器等需要灵活控制执行顺序的场景中具有重要价值。

# 先调用函数还是先返回值

### 思考过程

嗯，用户问的是在PHP代码中，return $middelwareA($request, $col0);这行代码是先调用中间件$middlewareA还是先返回值。我需要仔细分析这个执行顺序。
首先，用户可能是在学习中间件或回调函数的概念，特别是在PHP中使用闭包的情况。之前的对话中，用户已经接触了中间件链的构建和执行流程，现在可能对具体的执行顺序有疑问。
PHP中的函数调用是立即执行的，所以当执行$middelwareA($request, $col0)时，中间件A会立即被调用。这里的$middelwareA是一个闭包，接受$request和$next参数。当调用这个闭包时，它会执行内部的逻辑，比如检查请求是否合法，然后调用$next，也就是$col0。
接下来，$col0作为最终处理器被调用，返回另一个闭包。因此，整个表达式$middelwareA($request, $col0)的结果就是$col0返回的那个闭包，然后通过return语句返回给调用者。
用户可能混淆了函数调用和返回值的顺序，认为return语句会先于函数执行，但实际上在PHP中，函数调用会在return之前完成。所以正确的顺序是先执行中间件A，处理请求，然后中间件A内部调用$col0，$col0返回闭包，最后这个闭包作为结果被返回。
需要确认用户是否理解函数调用的立即执行特性，以及闭包作为返回值时的延迟执行机制。可能用户以为返回的是未执行的闭包，但实际上中间件A已经被调用了，而闭包是在中间件A内部被触发后才执行的。
此外，用户可能在调试代码时遇到了执行顺序的问题，比如期望某些代码在特定时间执行，但结果不符合预期。需要强调中间件链的构建和执行阶段的不同，构建阶段中间件被包裹，但实际执行是在调用链之后。
总结来说，用户需要明确在PHP中，函数调用是立即发生的，而闭包作为返回值则允许后续的执行。因此，中间件A先被调用，处理请求后，返回的闭包由后续代码决定何时执行。



在PHP中，`return $middelwareA($request, $col0);` 的执行顺序是 **先调用 `$middelwareA` 函数，再返回值**。具体过程如下：

---

### 执行顺序解析
#### 1. 步骤分解
```php
return $middelwareA($request, $col0);
```
- **第一步**：调用 `$middelwareA($request, $col0)`  
  立即执行中间件A的函数逻辑，包括：
  - 输出 `middlewareA hanlde request`
  - 检查 `$request` 是否符合要求
  - 调用 `$next`（即 `$col0`）

- **第二步**：获取返回值  
  `$middelwareA` 的返回值是 `$col0` 的执行结果（即闭包函数）

- **第三步**：返回最终值  
  将 `$middelwareA` 的返回值（闭包）作为外层函数的返回值

---

### 执行时序图
```
调用 $middelwareA() 
    ↓
执行中间件A的代码逻辑
    ↓
触发 $col0($request) 
    ↓
$col0 返回闭包函数 
    ↓
中间件A返回闭包函数 
    ↓
外层函数返回闭包函数
```

---

### 代码行为验证
#### 示例代码
```php
// 定义中间件A
$middelwareA = function ($req, $next) {
    echo "进入中间件A\n";
    $result = $next($req); // 调用 $col0
    echo "离开中间件A\n";
    return $result;
};

// 定义最终处理器
$col0 = function ($req) {
    echo "进入$col0\n";
    return function () { 
        echo "执行闭包\n";
    };
};

// 调用链
$result = $middelwareA('data', $col0);
echo "-----\n";
$result(); // 执行返回的闭包
```

#### 输出结果
```
进入中间件A
进入$col0
离开中间件A
-----
执行闭包
```

---

### 关键结论
1. **立即执行**  
   `$middelwareA()` 会在 `return` 语句中 **立刻执行**，其内部逻辑（包括对 `$col0` 的调用）在返回前完成。

2. **返回值本质**  
   `return` 语句返回的是 `$middelwareA` 的执行结果，而该结果本质上是 `$col0` 返回的闭包函数（**尚未执行**）。

3. **闭包延迟执行**  
   最终返回的闭包函数需要 **二次调用** 才会触发（如 `$result()`），此时才会输出 "Come in"。

---

### 与JavaScript的差异对比
| 行为                  | PHP                             | JavaScript（参考对比）         |
|-----------------------|---------------------------------|--------------------------------|
| 函数调用              | 立即执行                        | 立即执行                       |
| 闭包返回              | 返回未执行的函数对象             | 返回未执行的函数对象            |
| 链式调用语法          | 需手动处理（如 `$next($request)`）| 支持 `then()` 链式调用          |

---

### 常见误区
#### 错误理解：`return` 优先于函数调用
```php
// 误解：认为先返回闭包，再执行中间件A
return function () { ... }; // ❌ 实际不是这样
$middelwareA(...); 
```

#### 正确理解：函数调用在返回前完成
```php
// 实际执行顺序：
1. 执行 $middelwareA(...)
2. 获取其返回值
3. 返回该值
```

---

### 设计意义
这种模式实现了 **中间件的前置处理**：
1. 中间件A先验证请求
2. 验证通过后调用 `$col0` 生成响应闭包
3. 将响应闭包返回给调用方，由调用方决定最终执行时机

这种分离使得：
- 中间件可以拦截非法请求（如直接 `exit`）
- 业务逻辑（`$col0`）与验证逻辑解耦
- 响应处理延迟到合适时机（如模板渲染前）

---

总结：`return $middelwareA(...)` 是 **先完整执行中间件A的逻辑**（包含对下游处理器的调用），再将最终的闭包函数作为返回值传递出去，而返回的闭包函数需要后续显式调用才会执行。

# 调用时序图



以下是代码的完整执行时序图（基于合法请求 `$request = ['user' => 'tacks', 'age' => 18, 'money' => 1]`）：

---

### 时序图（垂直方向为时间顺序）
``` 
┌───────────────┐      ┌───────────────┐      ┌───────────────┐      ┌───────────────┐
│   $col3       │      │ middlewareC   │      │ middlewareB   │      │ middlewareA   │
├───────────────┤      ├───────────────┤      ├───────────────┤      ├───────────────┤
│ 调用入口       │ ──→ │ 1. 输出        │ ──→ │ 1. 输出        │ ──→ │ 1. 输出        │
│ $col3($request)│      │ "middlewarec  │      │ "middlewareB  │      │ "middlewareA  │
│               │      │ hanlde request"│      │ hanlde request"│      │ hanlde request"│
│               │      │ 2. 检查money>0 │      │ 2. 检查age≥18 │      │ 2. 检查数组结构│
│               │      │               │      │               │      │ 3. 检查user字段│
└───────┬───────┘      └───────┬───────┘      └───────┬───────┘      └───────┬───────┘
        │                      │                      │                      │
        │                      │                      │                      │
        │                      │                      │                      │
┌───────▼───────┐      ┌───────▼───────┐      ┌───────▼───────┐      ┌───────▼───────┐
│   $col2       │      │   $col1       │      │   $col0       │      │  闭包执行     │
├───────────────┤      ├───────────────┤      ├───────────────┤      ├───────────────┤
│ 调用链传递     │ ──→ │ 调用链传递     │ ──→ │ 1. 输出        │ ──→ │ 执行返回的闭包 │
│ middlewareC → │      │ middlewareB → │      │ "Callback     │      │ echo "Come in"│
│ $col2         │      │ $col1         │      │ handler..."   │      │               │
└───────────────┘      └───────────────┘      └───────┬───────┘      └───────────────┘
                                                      │
                                                      │
                                               ┌──────▼───────┐
                                               │  返回闭包     │
                                               └───────────────┘
```

---

### 分阶段执行细节

#### 阶段 1：中间件链触发
```php
$re = $col3($request); // 入口调用
```
1. **`$col3` 调用**  
   - 触发 `$middlewareC($request, $col2)`
   - 输出：`middlewarec hanlde request`
   - 检查 `$request['money'] > 0`

2. **`$middlewareC` 通过检查**  
   - 调用 `$col2($request)`（即 `$middlewareB`）

3. **`$middlewareB` 执行**  
   - 输出：`middlewareB hanlde request`
   - 检查 `$request['age'] ≥ 18`

4. **`$middlewareB` 通过检查**  
   - 调用 `$col1($request)`（即 `$middlewareA`）

5. **`$middlewareA` 执行**  
   - 输出：`middlewareA hanlde request`
   - 检查 `$request` 是数组且含 `user` 字段

6. **`$middlewareA` 通过检查**  
   - 调用 `$col0($request)`

---

#### 阶段 2：最终处理器执行
```php
// $col0 内部逻辑
echo 'Callback handler request...';
return function ($request) { /* 闭包 */ };
```
1. **输出核心逻辑标识**  
   输出：`Callback handler request, Through a set of middleware.`

2. **返回闭包**  
   - `$col0` 返回一个新的闭包函数
   - 此时 `$re` = 该闭包（尚未执行）

---

#### 阶段 3：闭包执行
```php
$re(); // 实际调用闭包（假设用户后续调用）
```
1. **执行闭包**  
   - 输出：`Come in`

---

### 完整输出结果
```
middlewarec hanlde request
middlewareB hanlde request
middlewareA hanlde request
Callback handler request, Through a set of middleware. 
Come in
```

---

### 关键路径说明
1. **中间件执行顺序**  
   实际执行顺序为 **C → B → A → $col0**，但代码的链式构建顺序是：
   ```
   $col3 = middlewareC → $col2 = middlewareB → $col1 = middlewareA → $col0
   ```
   这体现了中间件的 **洋葱模型外层到内核** 的包裹特性。

2. **闭包延迟执行**  
   最终返回的闭包需要 **二次调用** 才会触发，这种设计：
   - 允许在中间件全部通过后，再执行具体业务逻辑
   - 支持响应式编程（如HTTP响应生成前修改头信息）

3. **短路拦截机制**  
   任一中间件中触发 `exit` 会立即终止后续流程（如非法请求场景）。

---

### 执行流程可视化
``` 
[col3] → [MiddlewareC] → [col2] → [MiddlewareB] → [col1] → [MiddlewareA] → [col0] → [闭包]
   │           │               │            │             │            │             │
   │           │               │            │             │            │             │
   ▼           ▼               ▼            ▼             ▼            ▼             ▼
触发入口   检查money字段    传递调用链    检查age字段   传递调用链    检查user字段   最终业务逻辑
```

# 参考资料

[javascript - 怎样理解js回调函数就是异步的？ - SegmentFault 思否](https://segmentfault.com/q/1010000004842324)
[javascript - js的异步编程和回调函数之间的关系？ - SegmentFault 思否](https://segmentfault.com/q/1010000002577322?utm_source=sf-similar-question)
[从零起步，真正理解Javascript回调函数 - 个人文章 - SegmentFault 思否](https://segmentfault.com/a/1190000021942060)
[「硬核实战」回调函数到底是个啥？一文带你从原理到实战彻底掌握C/C++回调函数 - 江小康 - 博客园](https://www.cnblogs.com/xiaokang-coding/p/18801623)
---
aliases:
  - 异常
  - Error
  - try
  - catch
date: 2025-05-01
---

# 目录

```dataviewjs
const startHeadinglevel = 2;
const file = app.workspace.getActiveFile();
const { headings } = app.metadataCache.getFileCache(file);
 
// 全列表的形式
const raws = headings.filter(row => row.heading != "目录").map( p => {
    let repeatCount = Math.max((p.level - startHeadinglevel) * 4, 0);
    let spacesPrefix = ' '.repeat( repeatCount + 4 );
    let listSign = repeatCount > 0 ? '- ' : '';
    let linkText = `[[#${p.heading}]]`;
    let headingList = (p.level < startHeadinglevel) ? `- ${linkText}` : `${spacesPrefix}- ${linkText}`;
    return headingList;
  }
)
 
let result = raws.join('\n');
// 添加行距
dv.container.style.lineHeight = "1.5em";
dv.paragraph(result)
```

# 总览

```js

try {
	throw new SelfDefineException(errorMsg)
	// 如果发生异常，throw 后面的代码不再执行
} catch (err) {
	if (err instanceof SelfDefineException) {
		// 处理异常
	} else {
		throw err
	}
} finally {
	// 代码总是执行
}
```

- 异步代码中的异常如何处理？
- 变量和 try...catch...finally 中的局部变量
- `finally` 和 `return`

# 错误处理

## try catch

针对代码运行的结果与预期不符时的处理机制

- 一般情况下，如果发生错误，代码会立刻停止
- try catch 可以允许我们在发生错误时，可以捕获它，并自定义处理该错误的方式

### 语法

```js
try {

  // 代码...

} catch (err) {

  // 错误捕获

}
```

执行步骤：

1. 执行 try 中的代码
2. 如果 try 中无错误，则获取 catch 中的代码
3. 如果 try 中出现错误，则 try 会在出现错误的地方停止执行，控制流转向 catch(err)a 的开头。变量 err （自定义，可以用任何名称）将包含一个 error 对象，该对象包含了所发生事件的详细信息

### 同步执行

要捕获异步代码中的异常，则必须保证 try catch 在异步代码内

#### 无法捕获

```js
try {
  setTimeout(function() {
    noSuchVariable; // 脚本将在这里停止运行
  }, 1000);
} catch (err) {
  alert( "不工作" );
}
```

#### 可以捕获

```js
setTimeout(function() {
  try {
    noSuchVariable; // try...catch 处理 error 了！
  } catch {
    alert( "error 被在这里捕获了！" );
  }
}, 1000);
```

## Error 对象

发生错误时，JavaScript 会生成一个包含有关此 error 详细信息的对象。然后将该对象作为参数传递给 `catch`：

```js
try {
  // ...
} catch (err) { // <-- “error 对象”，也可以用其他参数名代替 err
  // ...
}
```

### 主要属性

对于所有内建的 error，error 有两个主要属性：name、message

- name：Error 名称。例如，对于一个未定义的变量，名称是 `"ReferenceError"`。
- message：关于 error 的详细文字描述。
- stack：当前的调用栈：用于调试目的的一个字符串，其中包含有关导致 error 的嵌套调用序列的信息。

```js
try {
  lalala; // error, variable is not defined!
} catch (err) {
  alert(err.name); // ReferenceError
  alert(err.message); // lalala is not defined
  alert(err.stack); // ReferenceError: lalala is not defined at (...call stack)

  // 也可以将一个 error 作为整体显示出来
  // error 信息被转换为像 "name: message" 这样的字符串
  alert(err); // ReferenceError: lalala is not defined
}
```

## throw 操作符

throw 操作符会生成一个 error 对象

```js
throw <error object>
```

技术上讲，我们可以将任何东西用作 error 对象。甚至可以是一个原始类型数据，例如数字或字符串，但最好使用对象，最好使用具有 `name` 和 `message` 属性的对象（某种程度上保持与内建 error 的兼容性）。

### 内建标准 Error 构造器

Javascript 中有很多内建标准 error 构造器：Error，SyntaxError，ReferenceError，TypeError 等。我们也可以使用它们来创建 error 对象。

它们的语法是：

```js
let error = new Error(message);
// 或
let error = new SyntaxError(message);
let error = new ReferenceError(message);
// ...
```

对于内建 error：

- name 属性刚好就是构造器的名字
- message 的值来在于构造器的传参

```js
let error = new Error("Things happen o_O");

alert(error.name); // Error
alert(error.message); // Things happen o_O
```

### 例子

```js
let json = '{ "age": 30 }'; // 不完整的数据

try {

  let user = JSON.parse(json); // <-- 没有 error

  if (!user.name) {
    throw new SyntaxError("数据不全：没有 name"); // (*)
  }

  alert( user.name );

} catch(err) {
  alert( "JSON Error: " + err.message ); // JSON Error: 数据不全：没有 name
}
```

在 `(*)` 标记的这一行，`throw` 操作符生成了包含着我们所给定的 `message` 的 `SyntaxError`，与 JavaScript 自己生成的方式相同。`try` 的执行立即停止，控制流转向 `catch` 块。

现在，`catch` 成为了所有 error 处理的唯一场所：对于 `JSON.parse` 和其他情况都适用。

## 再次抛出

前文提到了 catch 会成为所有 error 处理的唯一场所，但是如果不细分 error 就会导致调试的问题，例如明明是语法错误，但是控制台打印却是不正确的数据，会对调试造成困扰：

```js
let json = '{ "age": 30 }'; // 不完整的数据

try {
  user = JSON.parse(json); // <-- 忘记在 user 前放置 "let"

  // ...
} catch (err) {
  alert("JSON Error: " + err); // JSON Error: ReferenceError: user is not defined
  // (实际上并没有 JSON Error)
}
```

在我们的例子中，`try...catch` 旨在捕获“数据不正确”的 error。但实际上，catch 会捕获到 **所有** 来自于 `try` 的 error。在这儿，它捕获到了一个预料之外的 error，但仍然抛出的是同样的 `"JSON Error"` 信息。这是不正确的，并且也会使代码变得更难以调试。

为了避免此类问题，我们可以采用“重新抛出”技术。规则很简单：

**catch 应该只处理它知道的 error，并“抛出”所有其他 error**。

“再次抛出（rethrowing）”技术可以被更详细地解释为：

- Catch 捕获所有 error。
- 在 catch (err) {...} 块中，我们对 error 对象 err 进行分析。
- **如果我们不知道如何处理它，那我们就 throw err**。

通常，我们可以使用 instanceof 操作符判断错误类型：

```js
try {
  user = { /*...*/ };
} catch (err) {
  if (err instanceof ReferenceError) {
    alert('ReferenceError'); // 访问一个未定义（undefined）的变量产生了 "ReferenceError"
  }
}
```

下面这个示例演示了这种类型的 error 是如何被另外一级 try...catch 捕获的：

```js
function readData() {
  let json = '{ "age": 30 }';

  try {
    // ...
    blabla(); // error!
  } catch (err) {
    // ...
    if (!(err instanceof SyntaxError)) {
      throw err; // 再次抛出（不知道如何处理它）
    }
  }
}

try {
  readData();
} catch (err) {
  alert( "External catch got: " + err ); // 捕获了它！
}
```

上面这个例子中的 `readData` 只知道如何处理 `SyntaxError`，而外部的 `try...catch` 知道如何处理任意的 error。

## try catch finally

try...catch 结构可能还有一个代码子句（clause）：finally。

如果它存在，它在所有情况下都会被执行：

- try 之后，如果没有 error，
- catch 之后，如果有 error。

### 语法

```js
try {
   ... 尝试执行的代码 ...
} catch (err) {
   ... 处理 error ...
} finally {
   ... 总是会执行的代码 ...
}
```

### 作用

==`finally` 子句（clause）通常用在：当我们开始做某事的时候，希望无论出现什么情况都要完成某个任务==。

例如，我们想要测量一个斐波那契数字函数 fib(n) 执行所需要花费的时间。通常，我们可以在运行它之前开始测量，并在运行完成时结束测量。但是，如果在该函数调用期间出现 error 该怎么办？特别是，下面这段 fib(n) 的实现代码在遇到负数或非整数数字时会返回一个 error。

无论如何，finally 子句都是一个结束测量的好地方。

在这儿，finally 能够保证在两种情况下都能正确地测量时间 —— 成功执行 fib 以及 fib 中出现 error 时：

```js
let num = +prompt("输入一个正整数？", 35)

let diff, result;

function fib(n) {
  if (n < 0 || Math.trunc(n) != n) {
    throw new Error("不能是负数，并且必须是整数。");
  }
  return n <= 1 ? n : fib(n - 1) + fib(n - 2);
}

let start = Date.now();

try {
  result = fib(num);
} catch (err) {
  result = 0;
} finally {
  diff = Date.now() - start;
}

alert(result || "出现了 error");

alert( `执行花费了 ${diff}ms` );
```

- 在 `prompt` 弹窗中输入 `35` 来进行检查 —— 代码运行正常，先执行 `try` 然后是 `finally`。
- 如果你输入的是 `-1` —— 将立即出现 error，执行将只花费 `0ms`。以上两种情况下的时间测量都正确地完成了。

换句话说，函数 `fib` 以 `return` 还是 `throw` 完成都无关紧要。在这两种情况下都会执行 `finally` 子句。

> [!warning] 变量和 try...catch...finally 中的局部变量
请注意，上面代码中的 result 和 diff 变量都是在 try...catch 之前 声明的。
否则，如果我们使用 let 在 try 块中声明变量，那么该变量将只在 try 块中可见。

> [!warning] `finally` 和 `return`
`finally` 子句适用于 `try...catch` 的 **任何** 出口。这包括显式的 `return`。

在下面这个例子中，在 `try` 中有一个 `return`。在这种情况下，`finally` 会在控制转向外部代码前被执行：

```js
function func() {

  try {
    return 1;

  } catch (err) {
    /* ... */
  } finally {
    alert( 'finally' );
  }
}

alert( func() ); // 先执行 finally 中的 alert，然后执行这个 alert
```

## 全局 catch

全局错误处理程序 `window.onerror` 的作用通常不是恢复脚本的执行 —— 如果发生编程错误，恢复脚本的执行几乎是不可能的，它的作用是将错误信息发送给开发者。

### 语法

```js
window.onerror = function(message, url, line, col, error) {
  // ...
};
```

- message: error 信息
- url：发生 error 的脚本 URL
- line, col：发生 error 处的代码行号和列号
- error：error 对象

例如：

```js
<script>
  window.onerror = function(message, url, line, col, error) {
    alert(`${message}\n At ${line}:${col} of ${url}`);
  };

  function readData() {
    badFunc(); // 啊，出问题了！
  }

  readData();
</script>
```

# 自定义 Error

## 为什么要自定义 Error

- 网络操作中的异常，可以定义 HttpError
- 数据库操作中的异常，可以定义 DbError
- 搜索操作中的异常，可以定义 NotFoundError 

## 如何自定义 Error

- 自定义 Error 属性：
	- 自定义 Error 应支持基本的 error 属性： message、name、stack
	- 自定义属性
- 继承 Error 对象，可以通过 obj instanceof Error 来识别 error 对象
- 形成层次结构，例如 HttpTimeoutError -> HttpError -> Error

## 包装异常

我们只想知道这里是否是“数据读取异常” —— 为什么发生了这样的 error 通常是无关紧要的（error 信息描述了它）。或者，如果我们有一种方式能够获取 error 的详细信息那就更好了，但前提是我们需要。

我们所描述的这项技术被称为“包装异常”。

- 我们将创建一个新的类 ReadError 来表示一般的“数据读取” error。
- 函数readUser 将捕获内部发生的数据读取 error，例如 ValidationError 和 SyntaxError，并生成一个 ReadError 来进行替代。
- 对象 ReadError 会把对原始 error 的引用保存在其 cause 属性中。

之后，调用 readUser 的代码只需要检查 ReadError，而不必检查每种数据读取 error。并且，如果需要更多 error 细节，那么可以检查 readUser 的 cause 属性。

下面的代码定义了 ReadError，并在 readUser 和 try..catch 中演示了其用法：

```js
class ReadError extends Error {
  constructor(message, cause) {
    super(message);
    this.cause = cause;
    this.name = 'ReadError';
  }
}

class ValidationError extends Error { /*...*/ }
class PropertyRequiredError extends ValidationError { /* ... */ }

function validateUser(user) {
  if (!user.age) {
    throw new PropertyRequiredError("age");
  }

  if (!user.name) {
    throw new PropertyRequiredError("name");
  }
}

function readUser(json) {
  let user;

  try {
    user = JSON.parse(json);
  } catch (err) {
    if (err instanceof SyntaxError) {
      throw new ReadError("Syntax Error", err);
    } else {
      throw err;
    }
  }

  try {
    validateUser(user);
  } catch (err) {
    if (err instanceof ValidationError) {
      throw new ReadError("Validation Error", err);
    } else {
      throw err;
    }
  }

}

try {
  readUser('{bad json}');
} catch (e) {
  if (e instanceof ReadError) {
    alert(e);
    // Original error: SyntaxError: Unexpected token b in JSON at position 1
    alert("Original error: " + e.cause);
  } else {
    throw e;
  }
}
```


[自定义 Error，扩展 Error](https://zh.javascript.info/custom-errors)
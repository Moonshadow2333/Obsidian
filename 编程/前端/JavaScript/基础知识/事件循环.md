---
aliases:
  - JS
  - EventLoop
date: 2025-04-06
---

# 目录

```dataviewjs
const startHeadinglevel = 2;
const file = app.workspace.getActiveFile();
const { headings } = app.metadataCache.getFileCache(file);
 
// 全列表的形式
const raws = headings.filter(row => row.heading != "目录").map( p => {
    let repeatCount = Math.max((p.level - startHeadinglevel) * 4, 0);
    let spacesPrefix = ' '.repeat( repeatCount + 4 );
    let listSign = repeatCount > 0 ? '- ' : '';
    let linkText = `[[#${p.heading}]]`;
    let headingList = (p.level < startHeadinglevel) ? `- ${linkText}` : `${spacesPrefix}- ${linkText}`;
    return headingList;
  }
)
 
let result = raws.join('\n');
// 添加行距
dv.container.style.lineHeight = "1.5em";
dv.paragraph(result)
```

# 前言

`Event Loop`即事件循环，是指浏览器或`Node`的一种解决`javaScript`单线程运行时不会阻塞的一种机制，也就是我们经常使用**[[异步]]**的原理[^1]。

# 事件循环

1. JS 是单线程，防止代码阻塞，JS 把代码（任务）分为：同步和异步
2. 同步代码交给 JS 引擎执行，异步代码交给宿主环境（Node 或浏览器）
3. 同步代码放入执行栈中，异步代码等待时机成熟送入任务队列排队
4. 执行栈执行完毕，会去任务队列看是否有异步任务，有就送到执行栈执行，反复循环查看执行，这个过程是事件循环

# 宏任务和微任务

JS 把异步任务分为宏任务和微任务

在 ES5 之后，Javascript 引入了 Promise，在不需要浏览器的情况下，Javascript 引擎自身也能够发起异步任务

## 宏任务

由宿主（浏览器、Node）发起：


| 任务（代码）                                   | 类型   | 环境    |
| ---------------------------------------------- | ------ | ------- |
| script                                         | 宏任务 | 浏览器  |
| 事件                                           | 宏任务 | 浏览器  |
| 网络请求（Ajax/Fetch）                         | 宏任务 | 浏览器  |
| setTimeOut() 一次性定时器/setInterval() 定时器 | 宏任务 | 浏览器  |

## 微任务

由JS 引擎发起的任务

| 任务（代码）                                   | 类型   | 环境    |
| ---------------------------------------------- | ------ | ------- |
| Promise                                        | 微任务 | JS 引擎 |

> [!warning]
> Promise 本身是同步，then/catch 的回调函数是异步的

## 宏/微任务执行顺序

三类代码[^3]：

- 同步代码（JS 执行栈/回调栈）
- 微任务的异步代码（JS 引擎）
	- process.nextTick(node)
	- Promise.then() catch()
	- Async/Await
	- Object.observe 等
- 宏任务的异步代码（宿主环境）
	- script (代码块)
	- sertTimeOut/setInterval 定时器

### 顺序

1. 同步任务
2. 微任务的异步代码
3. 宏任务的异步代码

# 事件和回调函数[^2]

"任务队列"是一个事件的队列（也可以理解成消息的队列），IO设备完成一项任务，就在"任务队列"中添加一个事件，表示相关的异步任务可以进入"执行栈"了。主线程读取"任务队列"，就是读取里面有哪些事件。

"任务队列"中的事件，除了IO设备的事件以外，还包括一些用户产生的事件（比如鼠标点击、页面滚动等等）。只要指定过回调函数，这些事件发生时就会进入"任务队列"，等待主线程读取。

所谓"回调函数"（callback），就是那些会被主线程挂起来的代码。异步任务必须指定回调函数，当主线程开始执行异步任务，就是执行对应的回调函数。

"任务队列"是一个先进先出的数据结构，排在前面的事件，优先被主线程读取。主线程的读取过程基本上是自动的，只要执行栈一清空，"任务队列"上第一位的事件就自动进入主线程。但是，由于存在后文提到的"定时器"功能，主线程首先要检查一下执行时间，某些事件只有到了规定的时间，才能返回主线程。

# 事件循环练习网站

[JS Visualizer 9000](https://www.jsv9000.app/)

# 参考

> [!note]
> - [JavaScript中的Event Loop（事件循环）机制 - 前端小码农 - SegmentFault 思否](https://segmentfault.com/a/1190000022805523)
> - [【JS】深入理解事件循环,这一篇就够了!(必看) - 知乎](https://zhuanlan.zhihu.com/p/87684858)
> - [深入理解js事件循环机制（浏览器篇） - lynnelv's blog](https://lynnelv.github.io/js-event-loop-browser)

[^1]: [一次弄懂Event Loop（彻底解决此类面试问题） - 知乎](https://zhuanlan.zhihu.com/p/55511602)
[^2]: [JavaScript 运行机制详解：再谈Event Loop - 阮一峰的网络日志](https://www.ruanyifeng.com/blog/2014/10/event-loop.html)
[^3]: [【前端八股文】事件循环-宏任务和微任务_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1G84y1B7hZ?spm_id_from=333.788.videopod.sections&vd_source=081641abeed94aff322f0473e2c1773d)

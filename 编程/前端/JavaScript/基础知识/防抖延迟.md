---
aliases:
  - JS
date: 2025-04-22
---

# 目录

```dataviewjs
const startHeadinglevel = 2;
const file = app.workspace.getActiveFile();
const { headings } = app.metadataCache.getFileCache(file);
 
// 全列表的形式
const raws = headings.filter(row => row.heading != "目录").map( p => {
    let repeatCount = Math.max((p.level - startHeadinglevel) * 4, 0);
    let spacesPrefix = ' '.repeat( repeatCount + 4 );
    let listSign = repeatCount > 0 ? '- ' : '';
    let linkText = `[[#${p.heading}]]`;
    let headingList = (p.level < startHeadinglevel) ? `- ${linkText}` : `${spacesPrefix}- ${linkText}`;
    return headingList;
  }
)
 
let result = raws.join('\n');
// 添加行距
dv.container.style.lineHeight = "1.5em";
dv.paragraph(result)
```

# 前言

上周用 Vue 写了一个表单页面，涉及到前后端交互，表单验证，错误提示等内容。自己写的代码不够清晰，就把[[代码优化|自己写的代码交给 AI 优化]]，AI 指出了很多[[async await和Promise混用|问题]]，并给出了建议，其中一项就是防抖延迟——确保事件被频繁触发时，只执行最后一次操作

# 例子

防抖延迟（Debounce）是一种**控制函数执行频率**的技术，确保在事件被**频繁触发**时，只执行**最后一次**操作，避免资源浪费或错误。

---

### 🌰 **最简单的例子：电梯关门按钮**
假设你进电梯后狂按关门按钮（每秒按5次）：  
1. **没有防抖**：电梯会尝试立刻关门5次，可能导致门反复开合，甚至故障。  
2. **有防抖延迟**（比如设定1秒）：  
   - 你疯狂按按钮时，电梯会**等待1秒内没有新操作**再关门。  
   - 如果期间你又按了一次，**重新开始1秒计时**。  
   - **最终**只会在你**最后一次按按钮的1秒后**执行关门。

---

### 💻 **代码示例（JavaScript）**
```javascript
function debounce(func, delay) {
  let timer;
  return function() {
    clearTimeout(timer); // 清除之前的计时
    timer = setTimeout(func, delay); // 重新开始计时
  };
}

// 使用：输入框搜索时，防抖延迟500毫秒
const searchInput = document.getElementById("search");
const doSearch = () => console.log("实际发起搜索请求");

searchInput.addEventListener("input", debounce(doSearch, 500));
```
- **效果**：用户疯狂输入时，只有停止输入**500毫秒后**，才会执行一次搜索。

---

### ⚙️ **核心逻辑**  
防抖延迟通过**重置计时器**，确保连续操作中只有**最后一次**生效，避免无效执行。常用于输入框、滚动事件、按钮点击等高频场景。
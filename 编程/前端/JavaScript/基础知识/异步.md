---
aliases:
  - JS
date: 2025-04-06
---

# 目录

```dataviewjs
const startHeadinglevel = 2;
const file = app.workspace.getActiveFile();
const { headings } = app.metadataCache.getFileCache(file);
 
// 全列表的形式
const raws = headings.filter(row => row.heading != "目录").map( p => {
    let repeatCount = Math.max((p.level - startHeadinglevel) * 4, 0);
    let spacesPrefix = ' '.repeat( repeatCount + 4 );
    let listSign = repeatCount > 0 ? '- ' : '';
    let linkText = `[[#${p.heading}]]`;
    let headingList = (p.level < startHeadinglevel) ? `- ${linkText}` : `${spacesPrefix}- ${linkText}`;
    return headingList;
  }
)
 
let result = raws.join('\n');
// 添加行距
dv.container.style.lineHeight = "1.5em";
dv.paragraph(result)
```

# 目标

理解什么是异步编程，为什么我们需要它，并简要了解 JavaScript 历史上异步函数是怎样被实现的。

# 什么是异步编程

异步编程技术使你的程序可以在执行一个可能长期运行的任务的同时继续对其他事件做出反应而不必等待任务完成。与此同时，你的程序也将在任务完成后显示结果[^1]。

---

异步编程的含义只有一个：

你不能在函数返回时，立即获得你想要执行的结果。

于是，你传入一个callback用以等待任务完成时，把结果告诉你。

setTimeout(xx,1000) 是模拟1秒后你所需要的指令完成任务告诉你结果的形式。

# 为什么要使用异步编程

同步函数耗时问题

这就是耗时的同步函数的基本问题。在这里我们想要的是一种方法，以让我们的程序可以：

- 通过调用一个函数来启动一个长期运行的操作
- 让函数开始操作并立即返回，这样我们的程序就可以保持对其他事件做出反应的能力
- 当操作最终完成时，通知我们操作的结果。

# 异步编程实现

- 事件处理程序
- 回调函数

## 事件处理程序

你提供的函数（事件处理程序）将在事件发生时被调用（而不是立即被调用）。如果“事件”是“异步操作已经完成”，那么你就可以看到事件如何被用来通知调用者异步函数调用的结果的。

## 回调

事件处理程序是一种特殊类型的[[回调函数_V0]]。而回调函数则是一个被传递到另一个函数中的会在适当的时候被调用的函数。正如我们刚刚所看到的：回调函数曾经是 JavaScript 中实现异步函数的主要方式。

# 相关问题

## 回调函数为什么可以实现异步



在编程中，**回调函数（Callback）本身并不直接实现异步**，但它是异步编程模式中的关键工具。回调函数的本质是将一个函数作为参数传递给另一个函数，在某个操作完成后被调用。而异步的核心在于**非阻塞的执行流程**，即某个操作不会阻塞后续代码的执行，而是在完成后通过回调通知程序。以下是回调函数与异步的关系详解：

---

### 一、回调函数的本质
回调函数是一种**编程模式**，允许在某个操作完成后触发特定的逻辑。例如：
```php
function fetchData($url, $callback) {
    // 模拟耗时操作（如网络请求）
    $data = "Result from $url";
    $callback($data); // 操作完成后调用回调函数
}

fetchData("https://example.com", function ($data) {
    echo "Received: $data";
});
```
- **同步回调**：回调函数在耗时操作完成后立即执行（如上述代码），此时整个流程是**同步阻塞的**。
- **异步回调**：回调函数在耗时操作完成后延迟执行，此时主线程/进程可以继续处理其他任务。

---

### 二、异步的关键：非阻塞操作
**异步编程的核心是“不等待”耗时操作完成**，而是继续执行后续代码。回调函数是实现这一目标的工具之一，但还需要底层机制支持：
1. **事件循环（Event Loop）**  
   在单线程环境中（如 JavaScript 的浏览器环境或 Node.js），通过事件循环监听异步操作（如 I/O、定时器）的完成，触发对应的回调。
   ```javascript
   // JavaScript 示例（异步）
   setTimeout(() => {
     console.log("This runs after 2 seconds");
   }, 2000);
   console.log("This runs immediately");
   ```
   - `setTimeout` 是非阻塞的，主线程继续执行后续代码。
   - 2秒后，事件循环将回调函数推入执行队列。

2. **多线程/进程**  
   在支持多线程的语言（如 Java、C#）中，耗时操作可以在后台线程执行，完成后通过回调通知主线程。

3. **非阻塞 I/O**  
   操作系统层面的非阻塞 I/O 允许程序在等待 I/O 操作时继续执行其他任务（如 Nginx、Node.js）。

---

### 三、回调函数在异步中的作用
在异步模型中，回调函数的作用是**定义异步操作完成后的处理逻辑**。例如：
```php
// PHP 使用 ReactPHP 实现异步 HTTP 请求（需安装库）
$loop = React\EventLoop\Factory::create();
$client = new React\HttpClient\Client($loop);

$request = $client->request('GET', 'https://example.com');
$request->on('response', function ($response) {
    $response->on('data', function ($chunk) {
        echo "Received chunk: $chunk\n";
    });
});
$request->end();

$loop->run();
```
- **事件循环（`$loop`）** 监听 HTTP 请求的完成。
- **回调函数**（如 `$response->on('data', ...)`）在数据到达时被触发。
- **主线程不阻塞**，可以处理其他事件。

---

### 四、用户代码的同步性分析
你提供的 PHP 中间件管道代码本质上是**同步执行链**，而非异步：
```php
function carry() {
    return function ($stack, $pipe) {
        return function ($passable) use ($stack, $pipe) {
            if (!is_callable($pipe)) {
                $pipe = function ($parameter, $next) { return $next($parameter); };
            }
            return call_user_func($pipe, $passable, $stack); // 同步调用
        };
    };
}
```
- **同步调用链**：每个中间件（`$pipe`）立即调用下一个中间件（`$stack`），形成类似递归的同步流程。
- **无异步机制**：代码中没有事件循环、多线程或非阻塞 I/O，所有操作按顺序执行。

---

### 五、为什么人们误以为回调等于异步？
1. **Node.js 的影响**  
   Node.js 广泛使用回调函数处理异步操作（如 `fs.readFile`），导致许多人将回调与异步直接关联。

2. **语法相似性**  
   异步库（如 JavaScript 的 `Promise`、PHP 的 `ReactPHP`）使用回调语法处理异步结果，强化了这种印象。

3. **误解回调的触发时机**  
   如果回调在非阻塞操作（如网络请求）完成后触发，则是异步；如果在阻塞操作（如 PHP 的 `array_map`）中立即触发，则是同步。

---

### 六、总结
- **回调函数 ≠ 异步**：回调是一种通用的编程模式，可用于同步或异步场景。
- **异步的核心是非阻塞**：需要底层机制（事件循环、多线程、非阻塞 I/O）的支持。
- **用户代码是同步的**：你提供的中间件管道通过闭包链实现顺序执行，没有异步特性。
- **实现异步的方法**：在 PHP 中，可通过扩展如 `ReactPHP`、`Swoole` 或 `AMP` 结合回调函数实现异步编程。

[^1]: [异步 JavaScript 简介 - 学习 Web 开发 | MDN](https://developer.mozilla.org/zh-CN/docs/Learn_web_development/Extensions/Async_JS/Introducing)

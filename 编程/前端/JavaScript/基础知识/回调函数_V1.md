---
aliases:
  - callback
  - 回调
date: 2025-05-01
---

# 目录

```dataviewjs
const startHeadinglevel = 2;
const file = app.workspace.getActiveFile();
const { headings } = app.metadataCache.getFileCache(file);
 
// 全列表的形式
const raws = headings.filter(row => row.heading != "目录").map( p => {
    let repeatCount = Math.max((p.level - startHeadinglevel) * 4, 0);
    let spacesPrefix = ' '.repeat( repeatCount + 4 );
    let listSign = repeatCount > 0 ? '- ' : '';
    let linkText = `[[#${p.heading}]]`;
    let headingList = (p.level < startHeadinglevel) ? `- ${linkText}` : `${spacesPrefix}- ${linkText}`;
    return headingList;
  }
)
 
let result = raws.join('\n');
// 添加行距
dv.container.style.lineHeight = "1.5em";
dv.paragraph(result)
```

# 前言

之前在学习[[00责任链模式|责任链模式]]的时候有写过一篇关于[[回调函数_V0|回调函数]]的笔记，当时的情况是边学边记，遇到了一个不懂的问题就去查资料问 AI，把查到的内容都复制到了那篇笔记中，所以非常杂乱，没有重点。刚好今天复习了一下 js 中的[[装饰器模式和转发，call和apply|包装器]]，联想到了回调函数，所以干脆重新梳理一下回调函数。

# 什么是回调函数

在 JavaScript 中，**回调函数**（callback function）是指作为参数传递给另一个函数并在某个时刻被调用的函数。这种机制允许你在异步操作完成时或特定事件发生时执行代码，使得 JavaScript 能够处理非阻塞操作。

基本概念
- 回调函数：一个作为参数传递给其他代码的函数，并在某些操作完成后或特定条件下被执行。
- 高阶函数：接受一个或多个函数作为输入或者输出一个函数的函数。使用回调函数的函数通常是高阶函数。

```js
function greet(name, callback) {
    console.log('Hello, ' + name);
    callback();
}

// 定义回调函数
function sayGoodbye() {
    console.log('Goodbye!');
}

// 使用回调函数
greet('Alice', sayGoodbye);
// 输出:
// Hello, Alice
// Goodbye!
```

# 回调函数作为函数的参数

回调函数是在已经有数据的前提下，传入一个方法，然后用我们传入的方法去操作那个已经存在的数据[^1]

## 函数的结构

- function 关键字
- 函数名
- 参数
- 函数体
- 返回值

```js
function foo([...arg1]) {
	// 函数体
}
```

- 函数的参数是可选的，可以为空，也可以不为空；
- 不为空时：
	- 参数的个数可以是一个也可以是多个
	- 参数的类型是字符串、数组、布尔型、数字，还可以是函数
- 当传入的参数是函数时，函数的功能（算法）由内外函数共同决定，可以实现解耦

例如：

![[装饰器模式和转发，call和apply#简单示例——透明缓存]]

# 脚注

[^1]: [从零起步，真正理解Javascript回调函数 - 个人文章 - SegmentFault 思否](https://segmentfault.com/a/1190000021942060#item-3)

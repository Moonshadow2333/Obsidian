---
aliases:
  - Vue
date: 2025-05-04
---

# 目录

```dataviewjs
const startHeadinglevel = 2;
const file = app.workspace.getActiveFile();
const { headings } = app.metadataCache.getFileCache(file);
 
// 全列表的形式
const raws = headings.filter(row => row.heading != "目录").map( p => {
    let repeatCount = Math.max((p.level - startHeadinglevel) * 4, 0);
    let spacesPrefix = ' '.repeat( repeatCount + 4 );
    let listSign = repeatCount > 0 ? '- ' : '';
    let linkText = `[[#${p.heading}]]`;
    let headingList = (p.level < startHeadinglevel) ? `- ${linkText}` : `${spacesPrefix}- ${linkText}`;
    return headingList;
  }
)
 
let result = raws.join('\n');
// 添加行距
dv.container.style.lineHeight = "1.5em";
dv.paragraph(result)
```



在 Vue 3 项目中，自定义异常（Custom Errors）的存放位置通常遵循以下约定，根据不同的使用场景和团队规范会有差异：

---

### 1. 最常用方案 - `src/utils/errors`
**适用场景**：中小型项目、通用错误类型  
**目录结构**：
```bash
src/
  └── utils/
      ├── errors/           # 错误类目录
      │    ├── ApiError.js  # 网络请求异常
      │    ├── BizError.js  # 业务逻辑异常
      │    └── index.js     # 统一导出
      └── http.js           # 网络请求封装
```

**示例代码**：
```javascript
// src/utils/errors/BizError.js
export class BizError extends Error {
  constructor(code, message) {
    super(message);
    this.name = 'BizError';
    this.code = code; // 自定义错误码
  }
}
```

---

### 2. 模块化方案 - `src/exceptions`
**适用场景**：大型项目、需要分类的错误体系  
**目录结构**：
```bash
src/
  └── exceptions/
      ├── http/          # 网络相关异常
      │    ├── ApiError.js
      │    └── TimeoutError.js
      ├── business/      # 业务相关异常
      │    ├── AuthError.js
      │    └支付异常 PaymentError.js
      └── index.js       # 统一导出
```

**示例代码**：
```javascript
// src/exceptions/http/ApiError.js
export class ApiError extends Error {
  constructor(status, data) {
    super(`API Error: ${status}`);
    this.status = status;
    this.data = data;
  }
}
```

---

### 3. 组合式API整合方案 - `src/composables/errors`
**适用场景**：配合组合式函数使用  
**目录结构**：
```bash
src/
  ├── composables/
  │    ├── useForm.js    # 表单逻辑
  │    └── errors/      # 错误处理组合函数
  │        └── useErrorHandler.js
  └── utils/
      └── errors.js     # 基础错误类
```

**示例代码**：
```javascript
// src/composables/errors/useErrorHandler.js
import { BizError } from '@/utils/errors';

export function useErrorHandler() {
  const handleError = (error) => {
    if (error instanceof BizError) {
      console.error('业务错误:', error.code, error.message);
    }
    // 其他处理...
  };

  return { handleError };
}
```

---

### 4. 按功能拆分方案（推荐）
**适用场景**：功能模块化的项目  
**目录结构**：
```bash
src/
  ├── modules/
  │    └── auth/
  │        ├── AuthError.js    # 认证相关异常
  │        └── services.js     # 认证服务
  └── utils/
      └── BaseError.js         # 基础错误类
```

**示例代码**：
```javascript
// src/modules/auth/AuthError.js
import { BaseError } from '@/utils/BaseError';

export class AuthError extends BaseError {
  constructor(code = 'AUTH_401', message = '未授权') {
    super(code, message);
  }
}
```

---

### 最佳实践建议
1. **分类存储**：根据错误类型（网络错误、业务错误、系统错误）建立子目录
2. **统一导出**：在目录的 `index.js` 中统一导出所有错误类
3. **继承体系**：建议建立基础错误类（如 `BaseError`），其他错误继承它
4. **文档注释**：为每个错误类添加 JSDoc 说明，例如：
   ```javascript
   /**
    * 业务逻辑异常
    * @extends Error
    */
   export class BizError extends Error {
     // ...
   }
   ```

--- 

### 完整基础错误类示例
```javascript
// src/utils/BaseError.js
export class BaseError extends Error {
  constructor(code, message, details) {
    super(message);
    this.name = this.constructor.name;
    this.code = code;    // 错误码 (如 'NETWORK_TIMEOUT')
    this.details = details; // 附加信息
    Error.captureStackTrace?.(this, this.constructor);
  }
}
```

通过合理的目录规划，可以大幅提升自定义异常的可维护性和代码可读性。

# 例子



以下是基于 **最常用方案** (`src/utils/errors`) 的完整代码示例，包含自定义异常的定义、使用场景和最佳实践：

---

### 目录结构
```bash
src/
  ├── utils/
  │    ├── errors/
  │    │    ├── ApiError.js     # 网络请求异常
  │    │    ├── BizError.js     # 业务逻辑异常
  │    │    ├── ValidateError.js # 表单验证异常
  │    │    └── index.js        # 统一导出
  │    └── request.js          # 封装 Axios 请求
  └── App.vue                  # 使用示例
```

---

### 1. 定义自定义异常类
#### (1) 基础网络异常 `ApiError.js`
```javascript
// src/utils/errors/ApiError.js
export class ApiError extends Error {
  constructor(status, message, data) {
    super(message);
    this.name = 'ApiError';
    this.status = status;  // HTTP 状态码 (如 404)
    this.data = data;      // 响应数据
  }
}
```

#### (2) 业务逻辑异常 `BizError.js`
```javascript
// src/utils/errors/BizError.js
export class BizError extends Error {
  constructor(code, message) {
    super(message);
    this.name = 'BizError';
    this.code = code;  // 业务错误码 (如 'USER_NOT_FOUND')
  }
}
```

#### (3) 表单验证异常 `ValidateError.js`
```javascript
// src/utils/errors/ValidateError.js
export class ValidateError extends Error {
  constructor(field, message) {
    super(`表单验证失败: ${message}`);
    this.name = 'ValidateError';
    this.field = field;  // 验证失败的字段名 (如 'password')
  }
}
```

#### (4) 统一导出 `index.js`
```javascript
// src/utils/errors/index.js
export * from './ApiError';
export * from './BizError';
export * from './ValidateError';
```

---

### 2. 在请求拦截器中使用
```javascript
// src/utils/request.js
import axios from 'axios';
import { ApiError, BizError } from './errors';

const instance = axios.create({
  baseURL: '/api'
});

// 响应拦截器 - 统一转换错误类型
instance.interceptors.response.use(
  response => response.data,
  error => {
    if (error.response) {
      // 转换 HTTP 错误为 ApiError
      const { status, data } = error.response;
      throw new ApiError(status, data.message || '请求失败', data);
    } else if (error.request) {
      // 无响应错误 (如网络断开)
      throw new ApiError(0, '网络连接失败');
    } else {
      // 其他错误
      throw error;
    }
  }
);

export default instance;
```

---

### 3. 在 Vue 组件中使用
```js
<!-- src/App.vue -->
<script setup>
import { ref } from 'vue';
import request from '@/utils/request';
import { BizError, ValidateError } from '@/utils/errors';

// 提交表单
const submitForm = async () => {
  try {
    // 模拟业务错误
    const res = await request.post('/user/login', {
      username: 'admin',
      password: '123'
    });

    // 检查业务错误码
    if (res.code !== 200) {
      throw new BizError(res.code, res.message);
    }

    console.log('登录成功:', res.data);

  } catch (error) {
    // 分类处理错误
    if (error instanceof BizError) {
      console.error('业务错误:', error.code, error.message);
      alert(`操作失败: ${error.message}`);
    } else if (error instanceof ApiError) {
      console.error('接口错误:', error.status, error.message);
      alert('网络请求异常，请稍后重试');
    } else if (error instanceof ValidateError) {
      console.error('验证错误:', error.field);
      alert(`${error.field} 填写有误`);
    } else {
      console.error('未知错误:', error);
      alert('系统异常');
    }
  }
};

// 触发表单验证
const validatePassword = (value) => {
  if (value.length < 6) {
    throw new ValidateError('password', '密码至少6位');
  }
};
</script>

<template>
  <button @click="submitForm">提交</button>
</template>
```

---

### 4. 全局错误兜底处理
```javascript
// main.js
import { createApp } from 'vue';
import App from './App.vue';

const app = createApp(App);

// 全局错误监听
app.config.errorHandler = (error) => {
  console.error('全局捕获的未处理错误:', error);
  // 上报错误到 Sentry/Fundebug
};

app.mount('#app');
```

---

### 最佳实践
1. **错误分类清晰**  
   - `ApiError`: 网络层错误 (HTTP 状态码异常)  
   - `BizError`: 业务逻辑错误 (如余额不足)  
   - `ValidateError`: 表单验证错误

2. **错误信息结构化**  
   ```javascript
   // 抛出业务错误示例
   throw new BizError('USER_NOT_FOUND', '用户不存在');

   // 抛出表单错误示例
   throw new ValidateError('email', '邮箱格式错误');
   ```

3. **错误处理分层**  
   - 组件级: 处理可恢复错误 (如表单验证提示)  
   - 全局级: 监控未处理的严重错误

4. **配合 TypeScript**  
   ```typescript
   // 为错误类添加类型定义
   class BizError extends Error {
     constructor(public code: string, message: string) {
       super(message);
     }
   }
   ```

通过这种方式，可以构建一个高可维护性的错误处理体系，大幅提升代码健壮性。
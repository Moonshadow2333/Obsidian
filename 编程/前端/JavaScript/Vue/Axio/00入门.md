---
aliases:
  - Vue
  - 调接口
date: 2025-04-03
---

# 目录

```dataviewjs
const startHeadinglevel = 2;
const file = app.workspace.getActiveFile();
const { headings } = app.metadataCache.getFileCache(file);
 
// 全列表的形式
const raws = headings.filter(row => row.heading != "目录").map( p => {
    let repeatCount = Math.max((p.level - startHeadinglevel) * 4, 0);
    let spacesPrefix = ' '.repeat( repeatCount + 4 );
    let listSign = repeatCount > 0 ? '- ' : '';
    let linkText = `[[#${p.heading}]]`;
    let headingList = (p.level < startHeadinglevel) ? `- ${linkText}` : `${spacesPrefix}- ${linkText}`;
    return headingList;
  }
)
 
let result = raws.join('\n');
// 添加行距
dv.container.style.lineHeight = "1.5em";
dv.paragraph(result)
```

# 测试接口

`http://www.weather.com.cn/data/sk/101010100.html`

# 跨域问题

在请求时，如果出现了以下情况中的任意一种，那么它就是跨域请求：

跨域问题是指在浏览器环境下，当一个网页的脚本试图访问不同源（域名、协议或端口）的资源时，会发生跨域请求。这种问题主要是由于浏览器的同源策略导致的，该策略是为了防止恶意网站获取用户的敏感信息或进行攻击1。跨域问题出现的具体原因包括：

1. 域名不同：浏览器会限制不同域名之间的资源访问。

2. 端口不同：同源策略也包括端口号，因此不同端口的访问也会导致跨域问题。

3. 协议不同：如http和https之间的协议不同也会引发跨域问题2。


# 取消请求

```js
const controller = new AbortController();

axios.get('/foo/bar', {
   signal: controller.signal
}).then(function(response) {
   //...
});
// 取消请求
controller.abort()
```



以下是关于 Axios 取消请求的最简洁核心说明，配合直观示例：

---

### 一、核心作用
**主动终止正在进行的 HTTP 请求**，避免无效请求继续消耗资源，典型场景：  
1. 用户频繁操作导致重复请求（如快速切换选项卡）  
2. 页面跳转/组件销毁时取消未完成的请求  
3. 表单提交防抖（防止重复提交）

---

### 二、最简示例
```javascript
import axios from 'axios';

// 创建取消控制器
const controller = new AbortController();

// 发送请求（绑定取消信号）
axios.get('https://api.example.com/data', {
  signal: controller.signal // 关键配置
})
.then(response => console.log('成功:', response))
.catch(error => {
  if (axios.isCancel(error)) {
    console.log('请求被取消:', error.message);
  } else {
    console.log('请求失败:', error);
  }
});

// 取消请求（可触发在任意时机）
controller.abort('用户主动取消'); // 触发后，请求立即终止
```

---

### 三、使用场景
#### 1. 防抖搜索（保留最后一次请求）
```javascript
let currentController = null;

function search(keyword) {
  // 取消前一次请求
  if (currentController) currentController.abort();
  
  // 创建新控制器
  currentController = new AbortController();
  
  axios.get('/api/search', {
    params: { q: keyword },
    signal: currentController.signal
  }).then(/* ... */);
}
```

#### 2. 页面跳转时取消所有请求
```javascript
// 全局请求控制器
const globalController = new AbortController();

// 页面初始化时发送请求
axios.get('/api/data1', { signal: globalController.signal });
axios.get('/api/data2', { signal: globalController.signal });

// 离开页面时统一取消
window.addEventListener('beforeunload', () => {
  globalController.abort('离开页面');
});
```

---

### 四、实现原理
通过浏览器原生 **[AbortController](https://developer.mozilla.org/en-US/docs/Web/API/AbortController)** 实现：  
1. 创建 `AbortController` 实例  
2. 将实例的 `signal` 属性绑定到请求配置  
3. 调用 `controller.abort()` 触发取消

---

### 五、对比旧方案（CancelToken）
旧版本 Axios 使用 `CancelToken`（已弃用）：
```javascript
// ❌ 旧方案（仅作对比参考）
const source = axios.CancelToken.source();

axios.get('/api/data', {
  cancelToken: source.token
});

source.cancel('手动取消');
```

---

### 六、最佳实践
1. 在 Vue/React 组件销毁时自动取消：
```javascript
// React 示例（useEffect 清理函数）
useEffect(() => {
  const controller = new AbortController();
  axios.get('/api/data', { signal: controller.signal });
  
  return () => controller.abort(); // 组件卸载时取消
}, []);
```

2. 批量取消请求：
```javascript
// 创建控制器池
const controllers = new Set();

function sendRequest(url) {
  const controller = new AbortController();
  controllers.add(controller);
  
  axios.get(url, { signal: controller.signal })
    .finally(() => controllers.delete(controller));
}

// 取消全部请求
function cancelAll() {
  controllers.forEach(controller => controller.abort());
  controllers.clear();
}
```

---

通过取消请求机制，可以显著优化 Web 应用的性能和用户体验。


# 拦截器



以下是关于 Axios 拦截器的最简洁核心说明，配合直观示例：

---

### 一、拦截器的作用
**在请求发送前或响应返回后，统一添加处理逻辑**，避免在每个请求中重复代码。

---

### 二、最简示例
```javascript
import axios from 'axios';

// 添加请求拦截器（修改请求配置）
axios.interceptors.request.use(config => {
  config.headers.Token = '123'; // 统一添加 Token
  console.log('请求已发送:', config.url);
  return config; // 必须返回修改后的配置
});

// 添加响应拦截器（处理响应数据）
axios.interceptors.response.use(
  response => {
    console.log('响应已接收:', response.status);
    return response.data; // 直接返回核心数据（省去 response.data.xxx）
  },
  error => {
    console.error('请求失败:', error.response?.status);
    return Promise.reject(error); // 继续抛出错误供后续处理
  }
);

// 使用示例
axios.get('https://api.example.com/data')
  .then(data => console.log('成功:', data))
  .catch(error => console.log('失败:', error));
```

---

### 三、核心功能
| 场景         | 典型操作                          |
|--------------|-----------------------------------|
| **请求拦截器** | 添加 Token、修改参数、显示 Loading |
| **响应拦截器** | 统一错误处理、数据格式转换、隐藏 Loading |

---

### 四、使用场景
#### 1. 自动添加 Token
```javascript
axios.interceptors.request.use(config => {
  config.headers.Authorization = `Bearer ${localStorage.getItem('token')}`;
  return config;
});
```

#### 2. 统一处理错误
```javascript
axios.interceptors.response.use(
  response => response,
  error => {
    if (error.response.status === 401) {
      alert('登录过期，请重新登录');
      window.location.href = '/login';
    }
    return Promise.reject(error);
  }
);
```

#### 3. 接口耗时统计
```javascript
axios.interceptors.request.use(config => {
  config.metadata = { startTime: Date.now() };
  return config;
});

axios.interceptors.response.use(response => {
  const duration = Date.now() - response.config.metadata.startTime;
  console.log(`请求耗时: ${duration}ms`);
  return response;
});
```

---

### 五、拦截器 VS 普通请求
假设需要为每个请求添加 Token：
```javascript
// ❌ 没有拦截器（重复代码）
axios.get('/api/data', { headers: { Token: '123' } });
axios.post('/api/save', data, { headers: { Token: '123' } });

// ✅ 使用拦截器（统一处理）
// 只需在拦截器中配置一次
```

---

### 六、完整流程
```
请求发起 → 请求拦截器 → 发送服务器 → 响应返回 → 响应拦截器 → 最终处理
```

通过拦截器，你可以像流水线一样统一管理所有请求和响应逻辑。

# create



以下是关于 `axios.create` 的核心作用及使用场景的极简说明，配合直观代码示例：

---

### 一、核心作用
**创建独立的 Axios 实例**，避免不同模块的请求配置相互干扰，典型场景：
1. 对接多个不同域名/配置的后端服务
2. 需要为不同模块设置独立的拦截器
3. 避免全局默认配置被意外修改

---

### 二、最简示例
```javascript
import axios from 'axios';

// 创建独立实例
const api1 = axios.create({
  baseURL: 'https://api.service1.com',
  timeout: 5000,
  headers: { 'X-Custom-Header': 'foo' }
});

const api2 = axios.create({
  baseURL: 'https://api.service2.com',
  headers: { 'Authorization': 'Bearer 123' }
});

// 用法与默认 axios 完全一致
api1.get('/users') // 实际请求 https://api.service1.com/users
  .then(response => console.log(response.data));

api2.post('/orders', { data: 1 }) // 自动携带 Authorization 头
```

---

### 三、使用场景
#### 1. 对接多后端服务
```javascript
// 微信支付服务
const wechatPayAPI = axios.create({
  baseURL: 'https://pay.wechat.com/v3',
  headers: {
    'Content-Type': 'application/json',
    'Wechat-Secret': 'xxxxx'
  }
});

// 支付宝服务
const alipayAPI = axios.create({
  baseURL: 'https://openapi.alipay.com/gateway',
  timeout: 10000
});
```

#### 2. 独立拦截器管理
```javascript
// 文件上传专用实例
const uploadAPI = axios.create({
  baseURL: '/upload'
});

// 单独为上传添加进度拦截器
uploadAPI.interceptors.request.use(config => {
  config.onUploadProgress = progress => {
    console.log(`上传进度: ${Math.round(progress.loaded / progress.total * 100)}%`);
  };
  return config;
});
```

---

### 四、与默认实例的关系
| 特性         | 默认实例 `axios`       | 自定义实例 `axios.create()`    |
|--------------|-----------------------|-------------------------------|
| **配置隔离**   | 全局共享              | 独立配置，互不影响            |
| **适用场景**   | 通用请求              | 需要特殊配置的模块化请求      |
| **代码示例**   | `axios.get('/api')`   | `myInstance.get('/api')`      |

---

### 五、配置优先级
实例配置 > 创建时配置 > 全局默认配置  
```javascript
// 创建时配置
const instance = axios.create({ timeout: 3000 });

// 调用时配置（优先级最高）
instance.get('/data', { timeout: 5000 }); // 实际超时 5s
```

---

### 六、完整工作流
```javascript
// 创建实例
const authAPI = axios.create({
  baseURL: 'https://auth.example.com',
  headers: { 'App-Version': '1.0.0' }
});

// 添加实例专属拦截器
authAPI.interceptors.response.use(
  response => response.data,
  error => {
    if (error.response.status === 401) {
      window.location.href = '/login';
    }
    return Promise.reject(error);
  }
);

// 使用实例
async function login() {
  try {
    const user = await authAPI.post('/login', {
      username: 'admin',
      password: '123456'
    });
    console.log('登录成功:', user);
  } catch (err) {
    console.log('登录失败');
  }
}
```

---

通过 `axios.create` 可以实现更模块化、可维护性更好的请求管理。
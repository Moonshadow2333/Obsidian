---
aliases:
  - Element-Plus
date: 2025-04-13
---

# 目录

```dataviewjs
const startHeadinglevel = 2;
const file = app.workspace.getActiveFile();
const { headings } = app.metadataCache.getFileCache(file);
 
// 全列表的形式
const raws = headings.filter(row => row.heading != "目录").map( p => {
    let repeatCount = Math.max((p.level - startHeadinglevel) * 4, 0);
    let spacesPrefix = ' '.repeat( repeatCount + 4 );
    let listSign = repeatCount > 0 ? '- ' : '';
    let linkText = `[[#${p.heading}]]`;
    let headingList = (p.level < startHeadinglevel) ? `- ${linkText}` : `${spacesPrefix}- ${linkText}`;
    return headingList;
  }
)
 
let result = raws.join('\n');
// 添加行距
dv.container.style.lineHeight = "1.5em";
dv.paragraph(result)
```

# 表单

[基于element-plus封装通用型表单组件 - 前端哥](https://www.qianduange.cn/article/21141.html)

# 表单验证

以下是一个完整的 Element Plus 表单校验示例，包含表单验证、自定义校验规则和提交处理：

```js
<template>
  <el-form
    ref="formRef"
    :model="form"
    :rules="rules"
    label-width="120px"
    class="demo-form"
  >
    <!-- 用户名 -->
    <el-form-item label="用户名" prop="username">
      <el-input v-model="form.username" placeholder="请输入用户名" />
    </el-form-item>

    <!-- 邮箱 -->
    <el-form-item label="邮箱" prop="email">
      <el-input v-model="form.email" placeholder="请输入邮箱" />
    </el-form-item>

    <!-- 密码 -->
    <el-form-item label="密码" prop="password">
      <el-input
        v-model="form.password"
        type="password"
        placeholder="请输入密码"
        show-password
      />
    </el-form-item>

    <!-- 确认密码 -->
    <el-form-item label="确认密码" prop="confirmPassword">
      <el-input
        v-model="form.confirmPassword"
        type="password"
        placeholder="请再次输入密码"
        show-password
      />
    </el-form-item>

    <!-- 年龄 -->
    <el-form-item label="年龄" prop="age">
      <el-input-number v-model="form.age" :min="0" :max="150" />
    </el-form-item>

    <!-- 提交按钮 -->
    <el-form-item>
      <el-button type="primary" @click="submitForm">提交</el-button>
      <el-button @click="resetForm">重置</el-button>
    </el-form-item>
  </el-form>
</template>

<script setup>
import { reactive, ref } from 'vue'
import { ElMessage } from 'element-plus'

// 表单引用
const formRef = ref(null)

// 表单数据
const form = reactive({
  username: '',
  email: '',
  password: '',
  confirmPassword: '',
  age: undefined
})

// 校验规则
const rules = reactive({
  username: [
    { required: true, message: '请输入用户名', trigger: 'blur' },
    { min: 3, max: 10, message: '长度在3到10个字符', trigger: 'blur' }
  ],
  email: [
    { required: true, message: '请输入邮箱地址', trigger: 'blur' },
    { type: 'email', message: '请输入正确的邮箱地址', trigger: ['blur', 'change'] }
  ],
  password: [
    { required: true, message: '请输入密码', trigger: 'blur' },
    { min: 6, max: 16, message: '长度在6到16个字符', trigger: 'blur' }
  ],
  confirmPassword: [
    { required: true, message: '请再次输入密码', trigger: 'blur' },
    { validator: validatePassword, trigger: 'blur' }
  ],
  age: [
    { type: 'number', message: '年龄必须为数字' },
    { validator: checkAge, trigger: 'blur' }
  ]
})

// 自定义密码校验规则
const validatePassword = (rule, value, callback) => {
  if (value !== form.password) {
    callback(new Error('两次输入密码不一致!'))
  } else {
    callback()
  }
}

// 自定义年龄校验
const checkAge = (rule, value, callback) => {
  if (!value) {
    return callback(new Error('年龄不能为空'))
  }
  if (value < 18) {
    callback(new Error('必须年满18岁'))
  } else {
    callback()
  }
}

// 提交表单
const submitForm = async () => {
  try {
    // 表单验证
    await formRef.value.validate()
    
    // 验证通过后的处理
    ElMessage.success('提交成功!')
    console.log('表单数据:', form)
    
    // 这里可以添加提交到服务器的代码
    
  } catch (error) {
    ElMessage.error('请正确填写表单')
    console.log('验证失败:', error)
  }
}

// 重置表单
const resetForm = () => {
  formRef.value.resetFields()
}
</script>

<style scoped>
.demo-form {
  max-width: 600px;
  margin: 20px auto;
}
</style>
```

关键点说明：

1. **表单结构**：
- 使用 `<el-form>` 包裹整个表单
- 每个表单项使用 `<el-form-item>`
- `prop` 属性需要与 rules 中的字段名对应

2. **校验规则**：
- 支持多种校验类型：required、min/max、pattern、type 等
- 自定义校验使用 validator 属性
- 支持多个触发时机（blur/change）

3. **自定义校验**：
- `validatePassword` 验证两次密码是否一致
- `checkAge` 验证年龄是否符合要求

4. **表单操作**：
- `submitForm` 处理表单提交，使用 async/await 处理异步验证
- `resetForm` 重置表单

5. **注意事项**：
- 确保表单的 `model` 属性正确绑定
- 表单引用（formRef）必须通过 ref 获取
- 自定义校验函数必须调用 callback 或返回 Promise

常见问题处理：
1. 校验不生效：检查 prop 是否与 rules 中的字段名一致
2. 自定义校验无效：确保校验函数正确处理了所有情况
3. 数字类型验证：使用 type: 'number' 并确保 v-model 绑定的是数字类型
4. 动态校验规则：可以使用计算属性实现动态规则

可以根据具体需求调整校验规则和表单字段，此示例展示了 Element Plus 表单验证的完整流程和常用功能。

# 自定义验证规则



`validatePassword` 是 Element Plus 表单验证中的自定义校验函数，主要用于处理需要特殊验证规则的场景（比如密码一致性验证）。以下是它的完整使用方式详解：

---

### 作用说明
通常用于验证两个密码输入框是否一致的场景，例如：
- 注册时的密码和确认密码
- 修改密码时的新密码确认

---

### 使用步骤

#### 1. 在 rules 中声明验证规则
```javascript
const rules = reactive({
  // 密码字段的规则
  password: [
    { required: true, message: '请输入密码', trigger: 'blur' }
  ],
  
  // 确认密码字段使用自定义验证
  confirmPassword: [
    { required: true, message: '请再次输入密码', trigger: 'blur' },
    { validator: validatePassword, trigger: 'blur' } // 关键配置
  ]
})
```

#### 2. 编写验证函数
```javascript
const validatePassword = (rule, value, callback) => {
  // rule：当前校验规则对象（可获取字段名等信息）
  // value：当前输入框的值（confirmPassword的值）
  // callback：必须执行的回调函数
  
  if (value !== form.password) {
    callback(new Error('两次输入的密码不一致!')) // 验证失败
  } else {
    callback() // 验证成功
  }
}
```

---

### 完整组件示例
```js
<template>
  <el-form :model="form" :rules="rules" ref="formRef">
    <!-- 密码输入 -->
    <el-form-item label="密码" prop="password">
      <el-input v-model="form.password" type="password" />
    </el-form-item>

    <!-- 确认密码 -->
    <el-form-item label="确认密码" prop="confirmPassword">
      <el-input v-model="form.confirmPassword" type="password" />
    </el-form-item>

    <el-button @click="submit">提交</el-button>
  </el-form>
</template>

<script setup>
import { reactive, ref } from 'vue'

const form = reactive({
  password: '',
  confirmPassword: ''
})

const rules = reactive({
  password: [
    { required: true, message: '请输入密码', trigger: 'blur' },
    { min: 6, message: '密码至少6位', trigger: 'blur' }
  ],
  confirmPassword: [
    { required: true, message: '请确认密码', trigger: 'blur' },
    { validator: validatePassword, trigger: 'blur' }
  ]
})

// 自定义验证函数
const validatePassword = (rule, value, callback) => {
  if (value !== form.password) {
    callback(new Error('两次密码输入不一致!'))
  } else {
    callback()
  }
}

const formRef = ref(null)
const submit = () => {
  formRef.value.validate(valid => {
    if (valid) {
      console.log('验证通过，提交数据:', form)
    }
  })
}
</script>
```

---

### 参数详解
| 参数     | 说明                                                                 |
|----------|----------------------------------------------------------------------|
| rule     | 当前校验规则对象，包含 field（字段名）等信息                        |
| value    | 当前表单字段的值（即 confirmPassword 的值）                         |
| callback | 必须执行的回调函数，通过 `callback(error)` 返回校验结果：           |
|          | - 校验成功：`callback()`                                            |
|          | - 校验失败：`callback(new Error('错误提示'))`                       |

---

### 高级用法
#### 异步验证
```javascript
const validatePassword = (rule, value, callback) => {
  setTimeout(() => { // 模拟异步操作
    if (value !== form.password) {
      callback(new Error('密码不一致'))
    } else {
      callback()
    }
  }, 1000)
}
```

#### 动态错误提示
```javascript
const validatePassword = (rule, value, callback) => {
  if (!value) {
    callback(new Error('不能为空'))
  } else if (value.length < 6) {
    callback(new Error('密码至少6位'))
  } else if (value !== form.password) {
    callback(new Error('两次输入不一致'))
  } else {
    callback()
  }
}
```

---

### 常见问题
1. **校验不生效**：
   - 检查 `prop` 是否与 `rules` 的 key 一致
   - 确认 `validator` 是否正确绑定
   - 确保执行了 `callback()`

2. **获取不到其他字段值**：
   - 使用箭头函数保持 `this` 指向
   - 通过闭包直接访问表单对象（如示例中的 `form`）

3. **同步/异步处理**：
   - 同步验证直接判断后调用 `callback`
   - 异步验证需要在操作完成后调用 `callback`

---

通过这种自定义验证方式，可以灵活处理各种复杂表单验证需求，保持验证逻辑与组件代码的解耦。

# formRef.value.validate

`formRef.value.validate()` 是在 Vue 项目中使用 Element Plus 表单组件时，用于触发表单验证的方法。下面详细介绍它的作用、使用场景和注意事项：

### 作用
`formRef.value.validate()` 方法会遍历表单中所有带有 `prop` 属性的表单项（`el-form-item`），并根据其 `rules` 规则进行验证。如果所有表单项的验证都通过，该方法返回一个已解决的 Promise；如果有任何一项验证失败，该方法返回一个被拒绝的 Promise，并且会在控制台打印出相应的验证错误信息。

### 使用场景
在用户点击提交按钮时，通常会调用这个方法来确保用户输入的数据符合预先设定的规则。例如：

```js
<template>
  <el-form ref="formRef" :model="form" :rules="rules">
    <el-form-item label="用户名" prop="name">
      <el-input v-model="form.name"></el-input>
    </el-form-item>
    <el-form-item label="密码" prop="password">
      <el-input v-model="form.password" type="password"></el-input>
    </el-form-item>
    <el-form-item>
      <el-button type="primary" @click="handleSubmit">提交</el-button>
    </el-form-item>
  </el-form>
</template>

<script setup>
import { ref } from 'vue';

const formRef = ref(null);
const form = ref({
  name: '',
  password: ''
});

const rules = {
  name: [
    { required: true, message: '用户名不能为空', trigger: 'blur' }
  ],
  password: [
    { required: true, message: '密码不能为空', trigger: 'blur' }
  ]
};

const handleSubmit = async () => {
  try {
    await formRef.value.validate();
    // 如果验证通过，执行提交逻辑，例如发送网络请求
    console.log('表单验证通过，提交数据...');
  } catch (error) {
    console.log('表单验证失败', error);
  }
};
</script>
```

在上述代码中，当用户点击提交按钮时，`handleSubmit` 方法会调用 `formRef.value.validate()`。如果用户名和密码都填写了，验证通过，会执行后续的提交逻辑；如果有任何一项为空，验证失败，会在控制台打印出相应的错误信息。

### 注意事项
1. **`formRef` 必须正确绑定到 `el-form` 组件**：在模板中，`el-form` 组件的 `ref` 属性值必须与在脚本中定义的 `formRef` 变量名一致，否则 `formRef.value` 为 `null`，会导致报错 `Cannot read properties of null (reading 'validate')`。
2. **验证规则的配置**：表单项的 `rules` 规则需要正确配置。`required` 表示是否必填，`message` 是验证失败时显示的错误信息，`trigger` 定义了触发验证的时机，常见的有 `blur`（失去焦点）和 `change`（值改变）。
3. **异步验证**：如果验证规则中包含异步操作（例如异步校验用户名是否存在），需要确保正确处理 Promise。例如：

```javascript
const rules = {
  name: [
    {
      validator: async (rule, value, callback) => {
        try {
          // 模拟异步校验用户名是否存在
          const response = await axios.get(`/api/checkUsername?name=${value}`);
          if (response.data.exists) {
            callback(new Error('用户名已存在'));
          } else {
            callback();
          }
        } catch (error) {
          callback(error);
        }
      },
      trigger: 'blur'
    }
  ]
};
```

在这种情况下，`formRef.value.validate()` 返回的 Promise 会正确处理异步验证的结果。

总之，`formRef.value.validate()` 是确保表单数据合法性的重要方法，合理使用它可以提高用户输入数据的质量，并保证业务逻辑的正常运行。  

## 验证失败

```js
{
	confirmPassword: [Error]
}
```

## 异常处理



在 Element Plus 表单验证中，`cb`（即 `callback`）函数抛出的验证错误需要结合表单的 `validate()` 方法统一捕获。以下是具体处理方案：

---

### 一、验证错误处理流程
1. **规则定义**：在 `validator` 中使用 `callback` 返回错误  
2. **提交校验**：通过 `formRef.value.validate()` 统一捕获错误  
3. **全局处理**：在提交逻辑中统一处理验证错误和网络错误

---

### 二、完整代码示例
#### 1. 表单模板
```vue
<template>
  <el-form :model="form" :rules="rules" ref="formRef">
    <el-form-item label="用户名" prop="username">
      <el-input v-model="form.username"></el-input>
    </el-form-item>
    <el-button @click="handleSubmit">提交</el-button>
  </el-form>
</template>
```

#### 2. 验证规则与错误处理
```javascript
<script setup>
import { ref } from 'vue';
import { ElMessage } from 'element-plus';

const form = ref({ username: '' });
const formRef = ref(null);

// 验证规则（包含同步/异步示例）
const rules = {
  username: [
    // 同步验证
    { 
      required: true, 
      message: '用户名不能为空', 
      trigger: 'blur' 
    },
    // 自定义验证规则
    {
      validator: (rule, value, callback) => {
        // 示例：同步验证
        if (value.length < 3) {
          callback(new Error('至少3个字符')); // 触发验证错误
        } else {
          callback(); // 验证通过
        }
      },
      trigger: 'blur'
    },
    // 异步验证
    {
      validator: (rule, value, callback) => {
        if (!value) {
          callback(); // 允许空值（由required规则处理）
          return;
        }

        // 模拟API检查用户名
        setTimeout(() => {
          if (value === 'admin') {
            callback(new Error('该用户名已存在')); // 异步验证失败
          } else {
            callback(); // 异步验证通过
          }
        }, 1000);
      },
      trigger: 'blur'
    }
  ]
};

// 提交处理
const handleSubmit = async () => {
  try {
    // 触发全部验证规则
    await formRef.value.validate();
    
    // 验证通过后执行提交
    await submitToServer();
    ElMessage.success('提交成功');
  } catch (error) {
    // 统一错误处理
    if (error?.fields) {
      // 表单验证错误（自动显示在表单项下方）
      console.log('验证错误详情:', error.fields); 
    } else {
      // 网络错误/其他错误
      ElMessage.error(error.message || '请求失败');
    }
  }
};

// 模拟提交到服务器
const submitToServer = () => {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      // 模拟随机失败
      Math.random() > 0.5 
        ? resolve() 
        : reject(new Error('网络超时'));
    }, 1000);
  });
};
</script>
```

---

### 三、关键机制解析
#### 1. 错误类型区分
| 错误类型         | 特征                          | 处理方式                     |
|------------------|------------------------------|------------------------------|
| 表单验证错误      | `error` 包含 `fields` 属性    | 自动显示在表单项下方          |
| 网络/其他错误     | 普通 Error 对象              | 全局提示（如 ElMessage）      |

#### 2. `validate()` 方法的行为
- 校验所有表单项的规则  
- 任一验证失败则抛出包含 `fields` 的错误对象  
- 所有验证通过则返回 `Promise.resolve()`

#### 3. 异步验证注意事项
```javascript
// 异步验证必须确保调用 callback
{
  validator: (rule, value, callback) => {
    fetch('/api/check').then(res => {
      if (res.exist) callback(new Error('已存在'));
      else callback();
    }).catch(() => {
      callback(); // 网络错误时不阻断表单提交
    });
  }
}
```

---

### 四、最佳实践
1. **不要忘记调用 callback**  
   即使验证失败也要确保调用，否则会导致表单卡在验证状态

2. **分离验证逻辑与业务逻辑**  
   在 `validate()` 中只做数据校验，业务检查放在提交阶段

3. **统一错误处理入口**  
   使用 `try/catch` 包裹提交逻辑，统一处理所有错误类型

通过这种方案，可以实现表单验证错误与网络错误的统一管理，同时保持代码的简洁性和可维护性。

### error?.field



`error?.fields` 使用的是 JavaScript 的 **可选链操作符（Optional Chaining Operator）**，它是 ES2020 (ES11) 引入的新特性，用于简化深层嵌套对象属性的安全访问。

---

### 一、语法解析
| 代码             | 含义                                 |
|------------------|------------------------------------|
| `error?.fields`  | 安全访问 `error` 对象的 `fields` 属性 |

---

### 二、等效传统写法
```javascript
// 可选链写法
error?.fields

// 传统等价写法（无可选链）
error !== null && error !== undefined 
  ? error.fields 
  : undefined
```

---

### 三、核心作用
1. **避免因 `null`/`undefined` 导致的报错**  
   如果 `error` 为 `null` 或 `undefined`，直接访问 `error.fields` 会抛出 `TypeError`，而可选链会返回 `undefined`。

2. **简化深层属性访问**  
   特别适用于接口返回的嵌套数据结构，例如：
   ```javascript
   // 传统写法
   const city = user && user.address && user.address.city;

   // 可选链写法
   const city = user?.address?.city;
   ```

---

### 四、在表单验证场景中的应用
在 Element Plus 表单验证的错误处理中，`error` 对象的结构会根据错误类型变化：

#### 1. 表单验证错误
```javascript
error = {
  fields: {
    username: [{ message: '用户名不能为空' }]
  },
  // ...其他属性
}
```

#### 2. 网络请求错误
```javascript
error = new Error('请求超时') // 普通 Error 对象，无 fields 属性
```

使用可选链可以安全判断错误类型：
```javascript
try {
  await formRef.value.validate();
} catch (error) {
  // 使用可选链安全访问
  if (error?.fields) {
    console.log('表单验证错误:', error.fields);
  } else {
    console.log('其他错误:', error.message);
  }
}
```

---

### 五、浏览器兼容性
| 环境              | 支持情况       |
|------------------|--------------|
| Chrome ≥ 80      | ✅ 支持       |
| Firefox ≥ 74     | ✅ 支持       |
| Node.js ≥ 14.0.0 | ✅ 支持       |
| 旧版浏览器         | ❌ 不支持     |

**兼容方案**：使用 Babel 插件 `@babel/plugin-proposal-optional-chaining` 转译代码。

---

### 六、其他相关操作符
| 操作符              | 示例                  | 作用                   |
|---------------------|----------------------|-----------------------|
| 可选链调用 (`?.()`)  | `obj.method?.()`     | 安全调用可能不存在的函数 |
| 可选链数组 (`?.[]`)  | `arr?.[0]`           | 安全访问数组元素         |

---

通过可选链操作符，可以大幅提升代码的健壮性和可读性，尤其是在处理不确定结构的对象时。
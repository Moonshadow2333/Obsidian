---
aliases:
  - 设计模式
  - 闭包
  - 回调函数
  - 柯里化
  - array_reduce
date: 2025-04-12
---

# 目录

```dataviewjs
const startHeadinglevel = 2;
const file = app.workspace.getActiveFile();
const { headings } = app.metadataCache.getFileCache(file);
 
// 全列表的形式
const raws = headings.filter(row => row.heading != "目录").map( p => {
    let repeatCount = Math.max((p.level - startHeadinglevel) * 4, 0);
    let spacesPrefix = ' '.repeat( repeatCount + 4 );
    let listSign = repeatCount > 0 ? '- ' : '';
    let linkText = `[[#${p.heading}]]`;
    let headingList = (p.level < startHeadinglevel) ? `- ${linkText}` : `${spacesPrefix}- ${linkText}`;
    return headingList;
  }
)
 
let result = raws.join('\n');
// 添加行距
dv.container.style.lineHeight = "1.5em";
dv.paragraph(result)
```

# 什么是责任链模式

> 责任链模式 Chain-Of-Responsibilites 是一种行为设计模式 ，它允许你将请求沿着处理链进行传递，直到有一个处理器能够处理该请求。每个处理器都可以选择处理请求或将其传递给下一个处理器。

把一系列的处理器串成一个链条，链条上的每个处理传入的请求，并把请求传递个下一个处理器，直到出现异常终止或者已经到达链条末端。

# 基本原理

1. **闭包嵌套**
   - 外层回调函数通过返回新的函数，将执行权交给调用方，形成延迟执行（Lazy Evaluation）
   - 内层函数可以访问外层作用域的变量（闭包特性）

1. **执行控制权传递**

```javascript
function outer(callback) {
	 return function inner() {
	   // 在此处决定何时调用原始回调
	   return callback();
	 };
   }
```

# 参考代码

```php
/**
 * Pipeline 管道简易实现
 */
class Pipeline
{

    protected $passable;  // 请求对象
    protected $pipes = [];// 中间件

    // 设置请求对象
    public function send($passable)
    {
        $this->passable = $passable;
        return $this;
    }

    // 设置中间件
    public function through($pipes)
    {
        $this->pipes = is_array($pipes) ? $pipes : func_get_args();
        return $this;
    }

    // 设置责任链，并且调用闭包执行
    public function then(Closure $destination)
    {
        $pipeline = array_reduce(
            array_reverse($this->pipes()),
            $this->carry(),
            $this->prepareDestination($destination)
        );
        return $pipeline($this->passable);
    }

    // 获取中间件
    function pipes()
    {
        return $this->pipes;
    }

    // 迭代中间件构造责任链闭包
    function carry()
    {
        return function ($stack, $pipe) {
            return function ($passable) use ($stack, $pipe) {
                // 如果不是闭包，简单构造一下，可以不需要
                if(!is_callable($pipe)) {
                    $pipe = function ($parameter, $next) { return $next($parameter); };
                }
                return call_user_func($pipe, $passable, $stack); // 对应中间件 pipe($passable, $stack)
            };
        };
    }

    // 最终目的地调用
    function prepareDestination($dest)
    {
        return function ($passable) use ($dest) {
            return call_user_func($dest, $passable);
        };
    }
}

/**
 * 简易中间件方法
 *
 * @param $parameter 参数
 * @param $next 闭包
 * @return 
 */
function middlewareHandle($parameter, $next)
{
    $parameter++;
    echo sprintf("[%s] count:%s", __FUNCTION__, $parameter) . PHP_EOL;
    return $next($parameter);
}

// 通过中间件组的目的方法
$process = function ($request) {
    echo sprintf("[%s] request:%s", __FUNCTION__, $request) . PHP_EOL;
};


// 批量构造中间件组
$middleware = array_fill(0, 10, 'middlewareHandle');
// 追加最后一个
$middleware[] = function ($parameter, $next) {
    $parameter -= 100;
    echo sprintf("[中间件结束] count:%s", $parameter) . PHP_EOL;
    return $next($parameter);
};

// 追加第一个
array_unshift($middleware, function ($parameter, $next) {
    echo sprintf("[中间件开始] count:%s", $parameter) . PHP_EOL;
    return $next($parameter);
});

$request = 0;
(new Pipeline())
    ->send($request)
    ->through($middleware)
    ->then($process);
```

# 相关话题

## array_reduce 函数

### 功能

array_reduce — 用回调函数迭代地将数组简化为单一的值

```php
array_reduce(array $array, callable $callback, mixed $initial = null): mixed
```

array_reduce() 将回调函数 callback 迭代地作用到 array 数组中的每一个单元中，从而将数组简化为单一的值。

### 参数

- array: 输入的 array。
- callback: callback(mixed $carry, mixed $item): mixed
	- carry: 携带上次迭代的返回值； 如果本次迭代是第一次，那么这个值是 initial。
	- item: 携带了本次迭代的值。
- initial: 如果指定了可选参数 initial，该参数将用作处理开始时的初始值，如果数组为空，则会作为最终结果返回。

> [!note]
> -  callback 的传参个数是固定的，即必须是两个，且第一个是上一次迭代的返回值，第二个必须是本次迭代的值
> - callback 的返回值为本次迭代的结果，给下一次迭代用

### 例子

```php
<?php
function sum($carry, $item)
{
    $carry += $item;
    return $carry;
}

function product($carry, $item)
{
    $carry *= $item;
    return $carry;
}

$a = array(1, 2, 3, 4, 5);
$x = array();

var_dump(array_reduce($a, "sum")); // int(15)
var_dump(array_reduce($a, "product", 10)); // int(1200), 因为：10*1*2*3*4*5
```

### 模拟

```php
$initial = '10';
$carry = $initial; // 第一次迭代时会把 initial 当作初始值
$array = [1, 2, 3, 4, 5];
foreach($array as $item) {
   $carry = $item * $carry;
}
echo $carray; // 1200
```

## 回调函数

**回调函数**（callback function）是指作为参数传递给另一个函数并在某个时刻被调用的函数。

## 代码执行顺序

```php
return $next($request);
```

在 return 之前会先调用 `$next()` 函数，即函数调用是立即执行的，并且会优先于 return 执行

## 柯里化

[[00责任链模式#参考代码]] 中的 carry 函数有三个 return，一开始看不太懂，问了 AI，了解到了闭包的柯里化概念。

除了柯里化，还有没有理解 [[00责任链模式#array_reduce 函数]] 的参数 callback

callback 接收两个参数：

- 上次迭代的返回值
- 本次迭代的值

返回本次迭代的结果，供下次迭代使用

---

- 第一个 return 返回的就是 callback 函数
- 第二个 return 返回本次迭代的返回值，只不过返回的是一个闭包函数，而不是具体的值。

---

在 `carry` 函数中返回两个闭包（两层 `return`）的设计，是为了通过 **闭包的柯里化（Currying）** 和 **链式组合** 来逐步构建中间件调用链。这种设计是函数式编程中的常见模式，目的是将参数分步传递，最终形成一个可延迟执行的中间件管道。以下是详细解释：

### 闭包的柯里化（Currying）

**柯里化** 是一种将多参数函数转换为单参数函数链的技术。例如，一个接受三个参数的函数 `f(a, b, c)`，可以被拆解为 `f(a)(b)(c)`。  
在 `carry` 函数中，两层闭包的嵌套正是柯里化的体现：
1. **第一层闭包**（外层 `return`）：
   - 接收 `$stack`（下一个中间件链）和 `$pipe`（当前中间件）。
   - **返回一个新的闭包**，该闭包等待接收 `$passable`（请求数据）。
2. **第二层闭包**（内层 `return`）：
   - 接收 `$passable`（如 HTTP 请求对象）。
   - 执行中间件逻辑，并调用 `$pipe($passable, $stack)`。

这种设计将参数分阶段传递，使得中间件链可以 **灵活组合**，而无需一次性传递所有参数。

## 递归实现

```php
<?php

function chainByRe($request, $middlewares, $carry) {

    if (empty($middlewares)) {

        return $carry($request);

    }

  

    $first = array_shift($middlewares);

    return chainByRe($request, $middlewares, function ($request) use ($first, $carry) {

        return $first($request, $carry);

    });

}

// chain($user, $middlewares);

$carry = function ($request) {

    echo 'Middleware handle request'.PHP_EOL;

    return function () {

        return 'Come in';

    };

};

$re = chainByRe($user, $middlewares, $carry);
```

# 执行步骤

- 由里向外包裹
- 由外向内调用

---

顺序

- 中间件数组 [A, B , C]，初始闭包 init
- 翻转中间件数组得到 [C, B, A]
- 初次迭代，绑定 C, init => carry0
- 第二次迭代，绑定 B carry0 => carry1
- 第三次迭代，绑定 A carry1 => carry2
- 调用 carry2
- 执行中间件 A，在中间件中调用 carry1
- 执行中间件 B，在中间件中调用 carry0
- 执行中间件 C，在中间件中调用 init

在 carry 中执行当前中间件，在当前中间件中调用上一次 carry

# 优缺点

1. **延迟执行**  
    通过返回函数而非直接执行，控制权交给调用方决定触发时机
    
2. **动态组合**  
    允许运行时动态拼接处理逻辑（如中间件的灵活增减）
    
3. **执行上下文保留**  
    闭包特性可保留父级作用域的变量状态

**责任链模式，将请求与处理器解耦，让请求可以处理器责任链中传递和处理。** ，本质上，责任链就是形成链表结构，让每个节点的处理器可以选择处理或者转发请求给下一个处理器。

# 应用场景

- 中间件 / 拦截器
	- 例如 API 请求中的限流、认证等中间件
- try/catch
	- 多个 catch 异常捕获
- 多级缓存
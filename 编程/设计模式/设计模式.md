---
aliases:
  - 编程
  - Design Pattern
date: 2025-04-04
---

# 目录

```dataviewjs
const startHeadinglevel = 2;
const file = app.workspace.getActiveFile();
const { headings } = app.metadataCache.getFileCache(file);
 
// 全列表的形式
const raws = headings.filter(row => row.heading != "目录").map( p => {
    let repeatCount = Math.max((p.level - startHeadinglevel) * 4, 0);
    let spacesPrefix = ' '.repeat( repeatCount + 4 );
    let listSign = repeatCount > 0 ? '- ' : '';
    let linkText = `[[#${p.heading}]]`;
    let headingList = (p.level < startHeadinglevel) ? `- ${linkText}` : `${spacesPrefix}- ${linkText}`;
    return headingList;
  }
)
 
let result = raws.join('\n');
// 添加行距
dv.container.style.lineHeight = "1.5em";
dv.paragraph(result)
```

# 策略模式

[[编程/前端/JavaScript/Vue/ElementPlus/00入门#表单验证]]

[使用策略模式和简单工厂模式重写支付模块(一) | Laravel China 社区](https://learnku.com/articles/55410#replies)

# 责任链模式

[[递归#闭包]]

## 参考代码

```php
/**
 * Pipeline 管道简易实现
 */
class Pipeline
{

    protected $passable;  // 请求对象
    protected $pipes = [];// 中间件

    // 设置请求对象
    public function send($passable)
    {
        $this->passable = $passable;
        return $this;
    }

    // 设置中间件
    public function through($pipes)
    {
        $this->pipes = is_array($pipes) ? $pipes : func_get_args();
        return $this;
    }

    // 设置责任链，并且调用闭包执行
    public function then(Closure $destination)
    {
        $pipeline = array_reduce(
            array_reverse($this->pipes()),
            $this->carry(),
            $this->prepareDestination($destination)
        );
        return $pipeline($this->passable);
    }

    // 获取中间件
    function pipes()
    {
        return $this->pipes;
    }

    // 迭代中间件构造责任链闭包
    function carry()
    {
        return function ($stack, $pipe) {
            return function ($passable) use ($stack, $pipe) {
                // 如果不是闭包，简单构造一下，可以不需要
                if(!is_callable($pipe)) {
                    $pipe = function ($parameter, $next) { return $next($parameter); };
                }
                return call_user_func($pipe, $passable, $stack); // 对应中间件 pipe($passable, $stack)
            };
        };
    }

    // 最终目的地调用
    function prepareDestination($dest)
    {
        return function ($passable) use ($dest) {
            return call_user_func($dest, $passable);
        };
    }
}

/**
 * 简易中间件方法
 *
 * @param $parameter 参数
 * @param $next 闭包
 * @return 
 */
function middlewareHandle($parameter, $next)
{
    $parameter++;
    echo sprintf("[%s] count:%s", __FUNCTION__, $parameter) . PHP_EOL;
    return $next($parameter);
}

// 通过中间件组的目的方法
$process = function ($request) {
    echo sprintf("[%s] request:%s", __FUNCTION__, $request) . PHP_EOL;
};


// 批量构造中间件组
$middleware = array_fill(0, 10, 'middlewareHandle');
// 追加最后一个
$middleware[] = function ($parameter, $next) {
    $parameter -= 100;
    echo sprintf("[中间件结束] count:%s", $parameter) . PHP_EOL;
    return $next($parameter);
};

// 追加第一个
array_unshift($middleware, function ($parameter, $next) {
    echo sprintf("[中间件开始] count:%s", $parameter) . PHP_EOL;
    return $next($parameter);
});

$request = 0;
(new Pipeline())
    ->send($request)
    ->through($middleware)
    ->then($process);
```

## 为什么要返回两个return

在 `carry` 函数中返回两个闭包（两层 `return`）的设计，是为了通过 **闭包的柯里化（Currying）** 和 **链式组合** 来逐步构建中间件调用链。这种设计是函数式编程中的常见模式，目的是将参数分步传递，最终形成一个可延迟执行的中间件管道。以下是详细解释：

---

### 一、闭包的柯里化（Currying）
**柯里化** 是一种将多参数函数转换为单参数函数链的技术。例如，一个接受三个参数的函数 `f(a, b, c)`，可以被拆解为 `f(a)(b)(c)`。  
在 `carry` 函数中，两层闭包的嵌套正是柯里化的体现：
1. **第一层闭包**（外层 `return`）：
   - 接收 `$stack`（下一个中间件链）和 `$pipe`（当前中间件）。
   - **返回一个新的闭包**，该闭包等待接收 `$passable`（请求数据）。
2. **第二层闭包**（内层 `return`）：
   - 接收 `$passable`（如 HTTP 请求对象）。
   - 执行中间件逻辑，并调用 `$pipe($passable, $stack)`。

这种设计将参数分阶段传递，使得中间件链可以 **灵活组合**，而无需一次性传递所有参数。

---

### 二、中间件链的构建过程
假设中间件数组为 `[A, B, C]`，最终处理逻辑为 `$finalHandler`，构建过程如下：

#### 1. 初始状态
```php
$pipeline = $finalHandler; // 初始链是一个最终处理函数
```

#### 2. 反向包裹中间件
为了让中间件按顺序 `A → B → C` 执行，需要从后向前包裹中间件（底层闭包需要先被定义）：
```php
// 反向遍历中间件数组
foreach (array_reverse([A, B, C]) as $middleware) {
    $pipeline = carry()($pipeline, $middleware); // 逐步包裹闭包
}
```

#### 3. 闭包链的结构
每次调用 `carry()`，会生成一个新的闭包链。最终结构如下：
```php
$pipeline = function ($passable) use ($stack, $pipe) {
    // $stack 是下一个中间件链，$pipe 是当前中间件
    return $pipe($passable, $stack);
};
```
- **外层闭包**（`carry()` 返回的闭包）：负责将 `$stack` 和 `$pipe` 绑定到内层闭包。
- **内层闭包**（内层 `return`）：等待 `$passable`（请求数据），触发实际执行。

---

### 三、为什么需要两层闭包？
#### 1. **分离参数传递阶段**
- **第一阶段（绑定中间件）**：  
  通过外层闭包传递 `$stack`（后续中间件链）和 `$pipe`（当前中间件），将中间件的组合逻辑与执行逻辑解耦。
- **第二阶段（处理请求）**：  
  当实际请求（`$passable`）到来时，内层闭包才被调用，触发中间件链的执行。

#### 2. **实现链式延迟执行**
中间件链的构建是 **预先定义逻辑**，而实际执行是 **延迟触发** 的。通过两层闭包，可以：
- 先组合中间件链（不立即执行）。
- 在需要处理请求时，再传入 `$passable` 触发执行。

#### 3. **灵活支持中间件替换**
由于中间件链是动态组合的，可以通过替换 `$stack` 或 `$pipe` 来修改管道逻辑，而无需重新构建整个链。

---

### 四、代码执行流程示例
假设中间件 `A`、`B`、`C` 按顺序包裹，最终调用链如下：
```php
// 伪代码表示闭包链
$pipeline = function ($request) {
    return A($request, function ($request) {
        return B($request, function ($request) {
            return C($request, $finalHandler);
        });
    });
};
```
- 当调用 `$pipeline($request)` 时，触发 `A` 的执行。
- `A` 调用 `$next($request)`（即 `B` 的闭包）。
- `B` 调用 `$next($request)`（即 `C` 的闭包）。
- `C` 调用 `$next($request)`（即 `$finalHandler`）。

---

### 五、对比单层闭包设计
如果只用一层闭包（直接返回一个闭包），代码可能如下：
```php
function carry() {
    return function ($stack, $pipe, $passable) {
        return $pipe($passable, $stack);
    };
}
```
- **缺点**：必须在调用时一次性传递所有参数（`$stack`、`$pipe`、`$passable`），导致中间件链无法预先组合。
- **无法实现延迟执行**：中间件链的构建和执行必须同步完成，缺乏灵活性。

---

### 六、总结
- **两层闭包的设计**：通过柯里化分阶段传递参数，先绑定中间件逻辑，再延迟处理请求。
- **链式组合的灵活性**：支持动态构建中间件管道，按需触发执行。
- **函数式编程思想**：将逻辑封装为闭包，实现高内聚、低耦合的中间件架构。

这种设计是中间件管道模式的经典实现，广泛用于框架（如 Laravel、Express.js）中，以实现可扩展的请求处理流程。

# 工厂模式
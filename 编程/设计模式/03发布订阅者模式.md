---
aliases:
  - 解耦
  - 设计模式
  - 中间层
date: 2025-05-02
---

# 目录

```dataviewjs
const startHeadinglevel = 2;
const file = app.workspace.getActiveFile();
const { headings } = app.metadataCache.getFileCache(file);
 
// 全列表的形式
const raws = headings.filter(row => row.heading != "目录").map( p => {
    let repeatCount = Math.max((p.level - startHeadinglevel) * 4, 0);
    let spacesPrefix = ' '.repeat( repeatCount + 4 );
    let listSign = repeatCount > 0 ? '- ' : '';
    let linkText = `[[#${p.heading}]]`;
    let headingList = (p.level < startHeadinglevel) ? `- ${linkText}` : `${spacesPrefix}- ${linkText}`;
    return headingList;
  }
)
 
let result = raws.join('\n');
// 添加行距
dv.container.style.lineHeight = "1.5em";
dv.paragraph(result)
```

# 前言

# 使用场景

解耦网络模块和 UI 模块

路由、界面、网络、仓库

事件中心

# 修改前的代码

```js
import axios from "axios";
import event from './eventEmitter'

const ins = axios.create({
    baseURL: 'http:127.0.0.1:5000'
})

const successHandleer = (res) => {
    //
    console.log('访问成功')
    console.log(res)
}

const errorHandler = (error) => {
    if (error.response.status == 200) {
        event.emit('API:UN_AUTH') 
    } else if (error.response.status == 400) {
        event.emit('API:INVALID')
    }
}

ins.interceptors.response.use(successHandleer, errorHandler)

export default ins;
```

你的代码始终返回 `200` 是因为 **错误处理逻辑存在矛盾**，且 **拦截器没有正确返回数据**。以下是具体原因和修复方案：

---

### 问题分析
#### 1. 状态码逻辑矛盾
```javascript
const errorHandler = (error) => {
  if (error.response.status == 200) { // ❌ 矛盾点：200 是成功状态码
    event.emit('API:UN_AUTH') 
  } else if (error.response.status == 400) {
    event.emit('API:INVALID')
  }
}
```
- **HTTP 规范**：状态码 `2xx`（如 `200`）表示成功，**不会触发错误拦截器**。
- **矛盾点**：你在错误处理中检查 `error.response.status == 200`，但 `200` 实际上会进入 `successHandler`。

#### 2. 拦截器未正确返回数据
```javascript
ins.interceptors.response.use(successHandleer, errorHandler);
```
- **成功拦截器没有返回数据**：`successHandleer` 中只打印日志，没有 `return` 数据，导致后续 `.then()` 收到 `undefined`。
- **错误拦截器未抛出错误**：`errorHandler` 中没有返回 `Promise.reject()`，错误会被“吞掉”，外部无法捕获。

---

### 修复后的代码
```javascript
import axios from "axios";
import event from './eventEmitter';

const ins = axios.create({
  baseURL: 'http://127.0.0.1:5000' // 修复 URL 格式（缺少 //）
});

const successHandler = (res) => {
  console.log('访问成功', res.data);
  return res.data; // ✅ 必须返回数据，否则后续 then() 拿不到结果
};

const errorHandler = (error) => {
  if (!error.response) { // 网络错误或服务器无响应
    event.emit('API:NETWORK_ERROR');
    return Promise.reject(error);
  }

  const status = error.response.status;
  console.log('请求异常，状态码:', status);

  // 根据实际业务逻辑调整状态码判断
  if (status === 401) { // ✅ 401 表示未授权
    event.emit('API:UN_AUTH');
  } else if (status === 400) { // ✅ 400 表示请求无效
    event.emit('API:INVALID');
  } else if (status >= 500) { // 服务器内部错误
    event.emit('API:SERVER_ERROR');
  }

  return Promise.reject(error); // ✅ 必须抛出错误，否则外部 catch 无法捕获
};

ins.interceptors.response.use(successHandler, errorHandler);

export default ins;
```

---

### 关键修改说明
1. **修复 URL 格式**  
   原代码 `baseURL: 'http:127.0.0.1:5000'` 缺少双斜杠 `//`，正确格式是 `http://127.0.0.1:5000`。

2. **正确理解状态码**  
   - `2xx`: 成功，走 `successHandler`。
   - `4xx/5xx`: 失败，走 `errorHandler`。
   - 根据业务需求，在 `errorHandler` 中处理 `401`（未授权）、`400`（无效请求）等。

3. **拦截器必须返回数据/错误**  
   - 成功拦截器：需 `return res.data` 或 `return res`，否则后续 `.then()` 收到 `undefined`。
   - 错误拦截器：需 `return Promise.reject(error)`，否则错误会被静默处理。

---

### 测试用例
```javascript
// 使用示例
ins.get('/api/data')
  .then(data => console.log('最终成功数据:', data))
  .catch(err => console.log('最终捕获错误:', err));

// 模拟不同响应状态码的测试：
// - 200: 进入 successHandler，输出 "访问成功"
// - 401: 触发 API:UN_AUTH 事件，catch 捕获错误
// - 400: 触发 API:INVALID 事件，catch 捕获错误
// - 500: 触发 API:SERVER_ERROR 事件，catch 捕获错误
```

如果服务器返回 `200` 但携带业务错误信息（例如 `{ code: 500, message: '内部错误' }`），需要在 `successHandler` 中进一步处理：
```javascript
const successHandler = (res) => {
  if (res.data.code !== 200) { // 业务自定义错误码
    event.emit('API:BIZ_ERROR');
    return Promise.reject(res.data); // 转为错误
  }
  return res.data;
};
```
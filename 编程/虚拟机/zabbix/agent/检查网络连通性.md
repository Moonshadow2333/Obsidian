---
aliases:
  - zabbix
date: 2025-04-14
---

# 目录

```dataviewjs
const startHeadinglevel = 2;
const file = app.workspace.getActiveFile();
const { headings } = app.metadataCache.getFileCache(file);
 
// 全列表的形式
const raws = headings.filter(row => row.heading != "目录").map( p => {
    let repeatCount = Math.max((p.level - startHeadinglevel) * 4, 0);
    let spacesPrefix = ' '.repeat( repeatCount + 4 );
    let listSign = repeatCount > 0 ? '- ' : '';
    let linkText = `[[#${p.heading}]]`;
    let headingList = (p.level < startHeadinglevel) ? `- ${linkText}` : `${spacesPrefix}- ${linkText}`;
    return headingList;
  }
)
 
let result = raws.join('\n');
// 添加行距
dv.container.style.lineHeight = "1.5em";
dv.paragraph(result)
```



以下是一个用于配置 Zabbix 自定义网络监控项的 Shell 脚本，包含 ICMP 基础检测和 TCP 高级检测功能：

```bash
#!/bin/bash
set -euo pipefail

# ========================================
# 用户可配置参数
# ========================================
# 监控目标列表（支持IP/域名）
TARGETS=(
  "8.8.8.8"         # Google DNS
  "114.114.114.114" # 中国电信DNS
  "www.baidu.com" 
)

# 自定义脚本存放目录
SCRIPT_DIR="/etc/zabbix/scripts"
# 自定义配置文件目录
CONF_DIR="/etc/zabbix/zabbix_agentd.d"

# ========================================
# 函数：彩色输出
# ========================================
function color_echo() {
  local color=$1
  local msg=$2
  case $color in
    red)    echo -e "\033[31m$msg\033[0m" ;;
    green)  echo -e "\033[32m$msg\033[0m" ;;
    yellow) echo -e "\033[33m$msg\033[0m" ;;
    *)      echo "$msg" ;;
  esac
}

# ========================================
# 函数：验证服务状态
# ========================================
function validate_service() {
  if systemctl is-active --quiet zabbix-agent; then
    color_echo green "服务状态正常"
  else
    color_echo red "服务启动失败，请检查配置！"
    journalctl -u zabbix-agent --since "5 minutes ago"
    exit 1
  fi
}

# ========================================
# 主程序开始
# ========================================

# 创建目录结构
color_echo yellow "初始化目录结构..."
mkdir -p "$SCRIPT_DIR" "$CONF_DIR"
chown zabbix:zabbix "$SCRIPT_DIR" "$CONF_DIR"

# ========================================
# 生成网络检测脚本
# ========================================
cat > "$SCRIPT_DIR/network_monitor.sh" <<'EOF'
#!/bin/bash
set -euo pipefail

# 第一个参数为检测类型，第二个为目标地址
case $1 in
  "icmp")
    ping -c 4 -W 2 "$2" >/dev/null 2>&1
    echo $(( $? == 0 ? 1 : 0 ))
    ;;
  "tcp")
    timeout 2 bash -c ">/dev/tcp/${2//:/\/}" 2>/dev/null
    echo $(( $? == 0 ? 1 : 0 ))
    ;;
  *)
    echo 0
    ;;
esac
EOF

# 设置脚本权限
chmod 755 "$SCRIPT_DIR/network_monitor.sh"
chown zabbix:zabbix "$SCRIPT_DIR/network_monitor.sh"

# ========================================
# 生成监控项配置文件
# ========================================
CONF_FILE="$CONF_DIR/network_monitor.conf"

color_echo yellow "生成监控配置文件..."
cat > "$CONF_FILE" <<EOF
# 基础ICMP监控项
UserParameter=net.icmp[*], $SCRIPT_DIR/network_monitor.sh icmp \$1

# 高级TCP端口检测
UserParameter=net.tcp.port[*], $SCRIPT_DIR/network_monitor.sh tcp \$1

# 自动发现规则（JSON格式）
UserParameter=net.discovery, echo '{"data":[
  $(printf '  {"{#TARGET}":"%s"},\n' "${TARGETS[@]}" | sed '$s/,$//')
]}
EOF

# ========================================
# 重启服务生效
# ========================================
color_echo yellow "重新加载服务配置..."
systemctl restart zabbix-agent && validate_service

# ========================================
# 验证性测试
# ========================================
color_echo yellow "运行测试验证..."
test_target="8.8.8.8"
echo "ICMP测试结果：$(zabbix_agentd -t "net.icmp[$test_target]" -c "$CONF_FILE")"
echo "TCP端口测试：$(zabbix_agentd -t "net.tcp.port[${test_target}:53]" -c "$CONF_FILE")"

color_echo green "监控项配置完成！请到Zabbix Server添加以下监控项："
echo -e "\n【基础监控】"
echo "键值: net.icup[目标地址]"
echo "示例: net.icmp[8.8.8.8]"

echo -e "\n【高级监控】"
echo "键值: net.tcp.port[目标地址:端口]"
echo "示例: net.tcp.port[114.114.114.114:53]"

echo -e "\n【自动发现】"
echo "使用LLD自动发现规则: net.discovery"
```

---

### **脚本功能说明**

1. **双模式检测**：
   - **ICMP 基础检测**：验证基本网络连通性
   - **TCP 端口检测**：验证指定端口的可达性

2. **自动发现机制**：
   ```json
   {"data":[
     {"{#TARGET}":"8.8.8.8"},
     {"{#TARGET}":"114.114.114.114"},
     {"{#TARGET}":"www.baidu.com"}
   ]}
   ```
   支持在 Zabbix 中创建自动发现规则

3. **安全增强**：
   - 使用 `timeout` 命令防止检测脚本挂起
   - 严格的权限控制（`chown zabbix:zabbix`）

4. **验证机制**：
   - 服务状态检查
   - 自动执行测试用例验证配置

---

### **使用说明**

1. **修改配置**：
   ```bash
   # 编辑目标列表
   TARGETS=(
     "192.168.1.1"
     "10.0.0.1"
     "db-server:3306"
   )
   ```

2. **执行脚本**：
   ```bash
   chmod +x deploy_network_monitor.sh
   ./deploy_network_monitor.sh
   ```

3. **Zabbix 配置**：
   - 创建模板并添加以下监控项原型：
     - **键值**: `net.icmp[{#TARGET}]`
     - **键值**: `net.tcp.port[{#TARGET}]`
   - 配置触发器（示例）：
     ```text
     {Template:net.icmp[{#TARGET}].last()}=0
     ```

---

### **扩展建议**

1. **增加检测类型**：
   ```bash
   # 在case语句中添加新的检测类型
   "http")
     curl -Is --connect-timeout 3 "$2" | head -n1 | grep 200
     echo $?
     ;;
   ```

2. **性能优化**：
   ```bash
   # 添加缓存机制（30秒缓存）
   CACHE_FILE="/tmp/zabbix_network_cache"
   if [ ! -f "$CACHE_FILE" ] || [ $(date -r "$CACHE_FILE" +%s) -lt $(($(date +%s)-30)) ]; then
     # 执行检测并写入缓存
   fi
   cat "$CACHE_FILE"
   ```

3. **可视化增强**：
   ```bash
   # 在Zabbix中配置图形原型
   "Graph prototype": "Network Status for {#TARGET}"
   ```

该脚本实现了从基础网络检测到自动发现的完整监控解决方案，可根据实际需求灵活扩展检测类型和监控目标。

---

```bash
#!/bin/bash
## 变量定义
# 脚本所在路径
BASE_DIR=$(cd $(dirname $0);pwd)
## 使用 rpm 安装 Zabbix Agent
echo "开始使用 rpm 安装 Zabbix 客户端......"
rpm -ivh ${BASE_DIR}/zabbix-agent-6.0.35-release1.el5.i386.rpm
## 添加 Zabbix 使用的端口
echo "开始添加 10050 和 10051 端口......"
iptables -I RH-Firewall-1-INPUT -p tcp --dport 10050 -j ACCEPT
iptables -I RH-Firewall-1-INPUT -p tcp --dport 10051 -j ACCEPT
service iptables save
service iptables restart
chkconfig iptables on
## 创建使用文件夹，避免报错
echo "开始使创建 /var/lib/zabbix/ ......"
mkdir /var/lib/zabbix/
chmod 755 /var/lib/zabbix/
## 变更将配置文件替换
echo "开始使用覆盖配置文件......"
cp -f ${BASE_DIR}/zabbix_agentd.conf /etc/zabbix/  ## 将 ${BASE_DIR}/zabbix_agentd.conf 配置文件强制覆盖复制到 /etc/zabbix/ 目录，用于更新 Zabbix Agent 的配置。 .复制文件到另一个目录

## 启动 Zabbix 服务
service zabbix-agent start
chkconfig zabbix-agent on
```

# 获取当前脚本的目录



在 Shell 脚本中，`BASE_DIR=$(cd $(dirname $0);pwd)` 是一个常见的用于获取脚本所在绝对路径的方法，但在某些情况下可能不够健壮。以下是详细分析和改进建议：

---

### **原理解读**
```bash
BASE_DIR=$(cd $(dirname $0); pwd)
```
- **`$0`**：当前脚本的文件名（可能包含相对路径）
- **`dirname $0`**：提取脚本的目录路径
- **`cd`**：切换到该目录
- **`pwd`**：打印当前工作目录的绝对路径

---

### **潜在问题**
1. **路径包含空格**：
   ```bash
   # 若脚本路径为 "/path with space/script.sh"
   dirname $0 → /path with space → cd 失败
   ```
   **解决**：使用双引号包裹变量
   ```bash
   BASE_DIR=$(cd "$(dirname "$0")" && pwd)
   ```

2. **符号链接问题**：
   ```bash
   # 若脚本通过符号链接调用，$0 指向链接路径而非实际路径
   ln -s /real/path/script.sh /usr/bin/myscript
   ./myscript → $0 返回 /usr/bin/myscript
   ```
   **解决**：使用 `readlink` 解析真实路径
   ```bash
   BASE_DIR=$(cd "$(dirname "$(readlink -f "$0")")" && pwd)
   ```

3. **source 命令调用**：
   ```bash
   # 使用 source script.sh 或 . script.sh 时，$0 返回 shell 名称（如 bash）
   ```
   **解决**：改用 `BASH_SOURCE`
   ```bash
   BASE_DIR=$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)
   ```

---

### **推荐写法**
```bash
#!/bin/bash
# 兼容所有场景的健壮写法
BASE_DIR=$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd -P)
```

| 选项 | 说明 |
|------|------|
| `"${BASH_SOURCE[0]}"` | 即使脚本被 `source` 调用也能正确获取路径 |
| `-P` (physical) | 避免路径中的符号链接，返回物理路径 |

---

### **验证测试**
#### **场景 1：路径含空格**
```bash
mkdir "test dir"
cd "test dir"
echo "$BASE_DIR"  # 正确返回 "/path/to/test dir"
```

#### **场景 2：通过符号链接调用**
```bash
ln -s /real/path/script.sh /tmp/mylink
/tmp/mylink → BASE_DIR 返回 "/real/path"
```

#### **场景 3：使用 source 调用**
```bash
source script.sh → BASE_DIR 仍返回脚本真实路径
```

---

### **跨平台兼容性**
| 系统 | 命令 | 说明 |
|------|------|------|
| **Linux** | `readlink -f` | 直接解析符号链接 |
| **macOS** | `greadlink -f` | 需先安装 `coreutils` (`brew install coreutils`) |
| **BSD** | `realpath` | 需要额外安装 |

通用兼容写法：
```bash
# 自动选择解析方式
if [[ $(uname) == "Darwin" ]]; then
  READLINK="greadlink"
else
  READLINK="readlink"
fi

BASE_DIR=$(cd "$(dirname "$($READLINK -f "${BASH_SOURCE[0]}")")" && pwd)
```

---

### **应用场景**
1. **加载同级配置文件**：
   ```bash
   CONFIG_FILE="${BASE_DIR}/config.cfg"
   source "$CONFIG_FILE"
   ```

2. **调用子目录脚本**：
   ```bash
   "${BASE_DIR}/utils/helper.sh"
   ```

3. **日志文件定位**：
   ```bash
   LOG_PATH="${BASE_DIR}/logs/app.log"
   ```

---

通过这种健壮的路径获取方式，可以确保脚本在复杂环境（如含空格路径、符号链接、source 调用等）下仍能正确运行。